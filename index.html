<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>銀河系シミュレーター（ブラックホール吸引演出付き）</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: radial-gradient(circle at center, #000000 0%, #0a0a0a 80%, #111111 100%);
    }
    #timestamp {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 12px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="timestamp">Loading...</div>
  <canvas id="sim"></canvas>

  <script>
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;

    const timestampEl = document.getElementById("timestamp");
    const startDate = new Date("2025-01-01T00:00:00");
    let elapsedDays = 0;

    function updateTime() {
      elapsedDays += 0.05;
      const newDate = new Date(startDate.getTime() + elapsedDays * 86400000);
      timestampEl.textContent = newDate.toDateString();
    }

    const FADE_SPEED = 0.01;

    let blackHole = {
      x: 0,
      y: 0,
      radius: 50,
      active: false,
      angle: 0,
      opacity: 0,
      fadingOut: false,
      timeoutId: null,
      attractionRadius: 200
    };

    function spawnBlackHole() {
      if (blackHole.timeoutId) clearTimeout(blackHole.timeoutId);

      blackHole.x = Math.random() * canvas.width;
      blackHole.y = Math.random() * canvas.height;
      blackHole.radius = 40 + Math.random() * 15;
      blackHole.active = true;
      blackHole.opacity = 0;
      blackHole.fadingOut = false;
      blackHole.angle = 0;

      const duration = 15000 + Math.random() * 5000;
      blackHole.timeoutId = setTimeout(() => {
        blackHole.fadingOut = true;
      }, duration - 3000);
    }

    spawnBlackHole();
    setInterval(spawnBlackHole, 15000);

    const colors = ["#a9a9a9", "#e0c16c", "#4fc3f7", "#ff7043", "#fbc02d", "#d1c4e9", "#80cbc4"];
    const names = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus"];
    let planets = [];

    function generatePlanets() {
      planets = [];
      for (let i = 0; i < 7; i++) {
        const distance = 70 + i * 50;
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.008 + (i * 0.0015);
        const planetData = {
          name: names[i],
          angle,
          distance,
          speed,
          radius: 4 + i * 1.5,
          color: colors[i % colors.length],
          moons: []
        };
        if (i === 2) {
          planetData.moons.push({
            name: "Moon",
            distance: planetData.radius + 15,
            angle: Math.random() * Math.PI * 2,
            speed: 0.05,
            radius: 2,
            color: "#cccccc"
          });
        }
        planets.push(planetData);
      }
    }

    generatePlanets();

    let meteor = {
      x: -100,
      y: Math.random() * canvas.height,
      speed: 6 + Math.random() * 4,
      radius: 8 + Math.random() * 8,
      active: true
    };

    function resetMeteor() {
      meteor.x = -100;
      meteor.y = Math.random() * canvas.height;
      meteor.speed = 6 + Math.random() * 4;
      meteor.radius = 8 + Math.random() * 8;
      meteor.active = true;
    }

    function drawBlackHole() {
      if (!blackHole.active || blackHole.opacity <= 0) return;

      ctx.save();
      ctx.globalAlpha = blackHole.opacity;

      blackHole.angle += 0.02;
      ctx.translate(blackHole.x, blackHole.y);
      ctx.rotate(blackHole.angle);

      const gradient = ctx.createRadialGradient(0, 0, blackHole.radius * 0.5, 0, 0, blackHole.radius * 2);
      gradient.addColorStop(0, "rgba(255, 0, 255, 0.3)");
      gradient.addColorStop(0.5, "rgba(255, 255, 0, 0.2)");
      gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, blackHole.radius * 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.rotate(-blackHole.angle);
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(0, 0, blackHole.radius, 0, Math.PI * 2);
      ctx.fill();

      const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.005);
      ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 * pulse})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, blackHole.radius + 3, 0, Math.PI * 2);
      ctx.stroke();

      ctx.restore();

      ctx.fillStyle = "#fff";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Black Hole", blackHole.x, blackHole.y - blackHole.radius - 15);
      ctx.textAlign = "start";
    }

    function update() {
      // 太陽の描画
      ctx.beginPath();
      ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffaa";
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Sun", centerX, centerY + 30);
      ctx.textAlign = "start";
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (blackHole.active) {
        if (!blackHole.fadingOut && blackHole.opacity < 1) {
          blackHole.opacity += FADE_SPEED;
        } else if (blackHole.fadingOut) {
          blackHole.opacity -= FADE_SPEED;
          if (blackHole.opacity <= 0) {
            blackHole.opacity = 0;
            blackHole.active = false;
            blackHole.timeoutId = null;
          }
        }
      }

      drawBlackHole();

      for (let i = planets.length - 1; i >= 0; i--) {
        const p = planets[i];
        p.angle += p.speed;
        let x = centerX + Math.cos(p.angle) * p.distance;
        let y = centerY + Math.sin(p.angle) * p.distance;

        if (blackHole.active) {
          const dx = blackHole.x - x;
          const dy = blackHole.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < blackHole.attractionRadius) {
            const force = (blackHole.attractionRadius - dist) * 0.0005;
            x += dx * force;
            y += dy * force;
            const dCenterX = x - centerX;
            const dCenterY = y - centerY;
            p.distance = Math.sqrt(dCenterX * dCenterX + dCenterY * dCenterY);
            p.angle = Math.atan2(dCenterY, dCenterX);
          }
          if (dist < blackHole.radius + p.radius) {
            planets.splice(i, 1);
            continue;
          }
        }

        ctx.beginPath();
        ctx.arc(centerX, centerY, p.distance, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x, y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.font = "11px sans-serif";
        ctx.fillText(p.name, x + p.radius + 5, y + 4);

        if (p.moons) {
          for (let j = p.moons.length - 1; j >= 0; j--) {
            const m = p.moons[j];
            m.angle += m.speed;
            let mx = x + Math.cos(m.angle) * m.distance;
            let my = y + Math.sin(m.angle) * m.distance;

            if (blackHole.active) {
              const dx_m = blackHole.x - mx;
              const dy_m = blackHole.y - my;
              const dist_m = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
              if (dist_m < blackHole.attractionRadius * 0.5) {
                const force_m = (blackHole.attractionRadius * 0.5 - dist_m) * 0.001;
                mx += dx_m * force_m;
                my += dy_m * force_m;
                const dPlanetX = mx - x;
                const dPlanetY = my - y;
                m.distance = Math.sqrt(dPlanetX * dPlanetX + dPlanetY * dPlanetY);
                m.angle = Math.atan2(dPlanetY, dPlanetX);
              }
              if (dist_m < blackHole.radius + m.radius) {
                p.moons.splice(j, 1);
                continue;
              }
            }

            ctx.beginPath();
            ctx.arc(mx, my, m.radius, 0, Math.PI * 2);
            ctx.fillStyle = m.color;
            ctx.fill();
          }
        }
      }

      if (meteor.active) {
        meteor.x += meteor.speed;
        if (meteor.x > canvas.width + meteor.radius * 2) {
          meteor.active = false;
        } else {
          ctx.beginPath();
          ctx.arc(meteor.x, meteor.y, meteor.radius, 0, Math.PI * 2);
          ctx.fillStyle = "orange";
          ctx.fill();
        }
      }

      updateTime();
    }

    function animate() {
      update();
      requestAnimationFrame(animate);
    }

    animate();

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
      update();
    });

    window.addEventListener('unload', () => {
      if (blackHole.timeoutId) clearTimeout(blackHole.timeoutId);
    });
  </script>
</body>
</html>

