<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>é«˜åº¦ãªéŠ€æ²³ç³»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ âœ¦ Nâ€‘Body & ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç‰©ç†æ¼”ç®—</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    
    #controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      display: flex;
      gap: 10px;
      background: rgba(20, 20, 30, 0.7);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(100, 120, 255, 0.3);
      box-shadow: 0 0 15px rgba(70, 130, 240, 0.3);
      pointer-events: all;
    }
    
    button {
      background: rgba(60, 80, 170, 0.8);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    button:hover {
      background: rgba(80, 100, 220, 0.9);
      box-shadow: 0 0 8px rgba(120, 170, 255, 0.6);
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #cce;
    }
    
    input[type="range"] {
      accent-color: rgb(80, 120, 255);
    }
    
    #log {
      position: fixed;
      top: 10px;
      right: 10px;
      max-width: 340px;
      max-height: 90vh;
      overflow-y: auto;
      font: 12px/1.4 monospace;
      background: rgba(10, 10, 30, .7);
      color: #cce;
      border: 1px solid rgba(100, 120, 255, 0.3);
      padding: 8px 12px;
      border-radius: 8px;
      white-space: pre-line;
      pointer-events: none;
      box-shadow: 0 0 15px rgba(70, 130, 240, 0.3);
      transition: opacity 0.3s;
    }
    
    #log::-webkit-scrollbar {
      width: 5px;
    }
    
    #log::-webkit-scrollbar-thumb {
      background: rgba(100, 150, 255, 0.4);
      border-radius: 5px;
    }
    
    #stats {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(10, 10, 30, .7);
      color: #cce;
      border: 1px solid rgba(100, 120, 255, 0.3);
      padding: 8px 12px;
      border-radius: 8px;
      font: 12px/1.4 monospace;
      pointer-events: none;
      box-shadow: 0 0 15px rgba(70, 130, 240, 0.3);
    }
    
    .tooltip {
      position: absolute;
      background: rgba(20, 30, 60, 0.85);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      border: 1px solid rgba(100, 150, 255, 0.4);
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="sim"></canvas>
  <div id="ui">
    <div id="controls">
      <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
      <button id="addPlanetBtn">æƒ‘æ˜Ÿè¿½åŠ </button>
      <button id="addStarBtn">æ’æ˜Ÿè¿½åŠ </button>
      <button id="toggleTrailBtn">è»Œé“è¡¨ç¤º</button>
      <div class="slider-container">
        <span>æ™‚é–“é€Ÿåº¦:</span>
        <input type="range" id="timeSpeed" min="0.1" max="3" step="0.1" value="1">
        <span id="timeValue">1.0x</span>
      </div>
      <div class="slider-container">
        <span>ã‚ºãƒ¼ãƒ :</span>
        <input type="range" id="zoomLevel" min="0.2" max="2" step="0.1" value="1">
        <span id="zoomValue">1.0x</span>
      </div>
    </div>
  </div>
  <div id="log"></div>
  <div id="stats"></div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    /*â€“â€“â€“â€“â€“ CANVAS SETUP â€“â€“â€“â€“â€“*/
    const cvs = document.getElementById('sim');
    const ctx = cvs.getContext('2d');
    const DPR = window.devicePixelRatio || 1;
    let W, H, CX, CY;
    let scale = 1;
    let offsetX = 0, offsetY = 0; 
    let dragging = false;
    let lastMouseX, lastMouseY;
    
    function resize() {
      W = innerWidth;
      H = innerHeight;
      CX = W / 2;
      CY = H / 2;
      cvs.width = W * DPR;
      cvs.height = H * DPR;
      cvs.style.width = W + 'px';
      cvs.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    
    resize();
    addEventListener('resize', resize);
    
    const TAU = Math.PI * 2;
    const rand = (a, b) => Math.random() * (b - a) + a;
    const randInt = (a, b) => Math.floor(rand(a, b + 1));
    
    /*â€“â€“â€“â€“â€“ CONFIG PARAMETERS â€“â€“â€“â€“â€“*/
    let config = {
      timeScale: 1,
      showTrails: true,
      zoomLevel: 1,
      gravitationalConstant: 0.00020,
      diskRotationSpeed: 0.0005,
      particleCount: {
        stars: 700,
        diskParticles: 2200,
        dustParticles: 900
      },
      spawnRadius: {
        planets: 800
      },
      colors: {
        stars: ['#FFFFFF', '#F8F7FF', '#EEEEFF', '#FFEECC', '#FFF5CC']
      }
    };

    /*â€“â€“â€“â€“â€“ LOG PANEL â€“â€“â€“â€“â€“*/
    const logEl = document.getElementById('log');
    const logs = [];
    function addLog(msg) {
      const t = new Date().toLocaleTimeString('ja-JP', { hour12: false });
      logs.unshift(`[${t}] ${msg}`);
      if (logs.length > 60) logs.pop();
      logEl.textContent = logs.join('\n');
      logEl.scrollTop = 0;
    }
    
    /*â€“â€“â€“â€“â€“ BACKGROUND VISUALS â€“â€“â€“â€“â€“*/
    // Background gradient
    function drawBackground() {
      const gradient = ctx.createRadialGradient(CX, CY, 0, CX, CY, Math.max(CX, CY) * 1.5);
      gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
      gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
      gradient.addColorStop(1, 'rgba(5, 5, 15, 1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
    }
    
    // Distant stars with varying sizes, colors and brightness
    const bgStars = Array.from({ length: config.particleCount.stars }, () => ({
      x: rand(0, 1),
      y: rand(0, 1),
      r: rand(0.2, 1.8),
      a: rand(0.3, 0.95),
      color: config.colors.stars[randInt(0, config.colors.stars.length - 1)],
      ph: rand(0, TAU),
      s: rand(0.2, 1.2),
      twinkle: rand(0.01, 0.05)
    }));
    
    function drawBackgroundStars(time) {
      ctx.save();
      bgStars.forEach(s => {
        const a = s.a * (0.6 + 0.4 * Math.sin(time * 0.001 * s.s + s.ph));
        const size = s.r * (0.8 + 0.2 * Math.sin(time * s.twinkle + s.ph));
        
        // Star glow
        const glow = ctx.createRadialGradient(
          s.x * W, s.y * H, 0,
          s.x * W, s.y * H, size * 4
        );
        glow.addColorStop(0, s.color);
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        
        ctx.globalAlpha = a * 0.3;
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(s.x * W, s.y * H, size * 4, 0, TAU);
        ctx.fill();
        
        // Star core
        ctx.globalAlpha = a;
        ctx.fillStyle = s.color;
        ctx.beginPath();
        ctx.arc(s.x * W, s.y * H, size, 0, TAU);
        ctx.fill();
      });
      ctx.restore();
    }
    
    /*â€“â€“â€“â€“â€“ GALAXY DISK â€“â€“â€“â€“â€“*/
    const disk = [];
    const ARMS = 5; // è…•ã®æ•°ã‚’å¢—ã‚„ã™
    const STAR_PER_ARM = config.particleCount.diskParticles / ARMS; 
    
    // å¯†åº¦æ³¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã£ã¦ã€ã‚ˆã‚Šè‡ªç„¶ãªã‚¹ãƒ‘ã‚¤ãƒ©ãƒ«ã‚’ä½œæˆ
    for (let a = 0; a < ARMS; a++) {
      for (let i = 0; i < STAR_PER_ARM; i++) {
        const r = Math.pow(i / STAR_PER_ARM, 0.8) * 900 * rand(0.85, 1.15); // ã‚ˆã‚Šéç·šå½¢ãªåˆ†å¸ƒ
        const armWidth = 40 + r * 0.08; // è·é›¢ã«å¿œã˜ã¦è…•ã®å¹…ãŒåºƒãŒã‚‹
        const th = a * (TAU / ARMS) + r * 0.004 * Math.log(r + 50) + rand(-0.2, 0.2) * Math.exp(-r/500);
        
        // è…•ã®ä¸­ã§ã®ä½ç½®ï¼ˆä¸­å¿ƒç·šã‹ã‚‰ã®è·é›¢ï¼‰
        const fromCenter = rand(-1, 1) * armWidth;
        const perpAng = th + Math.PI/2;
        const xOffset = Math.cos(perpAng) * fromCenter;
        const yOffset = Math.sin(perpAng) * fromCenter;
        
        // ã‚ˆã‚Šè‡ªç„¶ãªåˆ†å¸ƒã®ãŸã‚ã«æŒ‡æ•°é–¢æ•°çš„è¡°é€€ã‚’ä½¿ç”¨
        const brightness = Math.exp(-r / 700) * rand(0.7, 1);
        
        // è‰²ç›¸ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ - å†…å´ã¯é»„è‰²ã£ã½ãã€å¤–å´ã¯é’ã£ã½ã
        const hue = r < 300 ? rand(40, 60) : rand(180, 260);
        
        disk.push({
          r,
          th,
          x: Math.cos(th) * r + xOffset,
          y: Math.sin(th) * r + yOffset,
          sz: rand(0.4, 2.0) * brightness,
          h: hue,
          s: rand(60, 90),
          l: rand(70, 90),
          spd: config.diskRotationSpeed / (0.2 + Math.sqrt(r) * 0.01),
          brightness,
          offset: {x: xOffset, y: yOffset}
        });
      }
    }
    
    // å¡µ/ã‚¬ã‚¹ã®ç²’å­ã‚’è¿½åŠ 
    const dust = [];
    for (let i = 0; i < config.particleCount.dustParticles; i++) {
      const r = Math.pow(rand(0, 1), 0.6) * 1000 * rand(0.5, 1.2);
      const th = rand(0, TAU);
      const density = Math.exp(-r / 500);
      
      dust.push({
        r,
        th,
        x: Math.cos(th) * r,
        y: Math.sin(th) * r,
        opacity: rand(0.01, 0.1) * density,
        color: rand(0, 1) > 0.5 ? 'rgba(100, 120, 255, ' : 'rgba(255, 200, 120, ',
        size: rand(60, 160) * density,
        spd: config.diskRotationSpeed / (0.4 + Math.sqrt(r) * 0.01)
      });
    }
    
    function drawGalaxyDisk(time, dt) {
      ctx.save();
      ctx.translate(CX + offsetX, CY + offsetY);
      ctx.scale(scale, scale);
      
      // ã¾ãšå¡µ/ã‚¬ã‚¹ã‚’æç”»ï¼ˆä½ã„é€æ˜åº¦ã§é‡ã­ã‚‹ï¼‰
      dust.forEach(d => {
        d.th += d.spd * dt * config.timeScale;
        d.x = Math.cos(d.th) * d.r;
        d.y = Math.sin(d.th) * d.r;
        
        ctx.globalAlpha = d.opacity;
        const gradient = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, d.size);
        gradient.addColorStop(0, d.color + '0.4)');
        gradient.addColorStop(1, d.color + '0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.size, 0, TAU);
        ctx.fill();
      });
      
      // æ¬¡ã«æ˜Ÿã‚’æç”»
      disk.forEach(s => {
        s.th += s.spd * dt * config.timeScale;
        s.x = Math.cos(s.th) * s.r + s.offset.x;
        s.y = Math.sin(s.th) * s.r + s.offset.y;
        
        // æ˜Ÿã®æ˜ã‚‹ã•ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
        const flickerAmt = 0.85 + 0.15 * Math.sin(time * 0.001 + s.r);
        const starAlpha = s.brightness * flickerAmt;
        
        // æ˜Ÿè‡ªä½“ã‚’æç”»
        ctx.globalAlpha = starAlpha;
        ctx.fillStyle = `hsl(${s.h}, ${s.s}%, ${s.l}%)`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.sz, 0, TAU);
        ctx.fill();
        
        // æ˜Ÿã®å‘¨ã‚Šã«å…‰ã‚‹ãƒãƒ­ãƒ¼åŠ¹æœã‚’è¿½åŠ 
        if (s.sz > 1.4) {
          const glow = ctx.createRadialGradient(
            s.x, s.y, 0,
            s.x, s.y, s.sz * 3
          );
          glow.addColorStop(0, `hsla(${s.h}, ${s.s}%, ${s.l}%, 0.8)`);
          glow.addColorStop(1, 'rgba(0,0,0,0)');
          
          ctx.globalAlpha = starAlpha * 0.4;
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.sz * 3, 0, TAU);
          ctx.fill();
        }
      });
      
      ctx.restore();
    }
    
    /*â€“â€“â€“â€“â€“ PHYSICS SYSTEM â€“â€“â€“â€“â€“*/
    // é‡åŠ›å®šæ•° G
    const G = config.gravitationalConstant;
    
    // å¤©ä½“ã‚¯ãƒ©ã‚¹
    class Body {
      constructor({name, color, mass, radius, x, y, vx, vy, type='planet', hasBelt = false}) {
        this.name = name;
        this.color = color;
        this.m = mass;
        this.r = radius;
        this.x = x;
        this.y = y;
        this.vx = vx || 0;
        this.vy = vy || 0;
        this.ax = 0;
        this.ay = 0;
        this.type = type;
        this.isFragment = !name;
        this.trail = [];
        this.trailMaxLength = 100;
        this.alive = true;
        this.created = Date.now();
        this.rings = [];
        
        // ãƒªãƒ³ã‚°ãŒã‚ã‚‹å ´åˆã¯ç”Ÿæˆ
        if (hasBelt) {
          const ringCount = randInt(1, 3);
          for (let i = 0; i < ringCount; i++) {
            this.rings.push({
              innerRadius: this.r * (1.6 + i * 0.8) * rand(0.9, 1.1),
              outerRadius: this.r * (2.2 + i * 0.8) * rand(0.9, 1.1),
              color: `hsla(${rand(20, 60)}, ${rand(40, 70)}%, ${rand(70, 90)}%, ${rand(0.4, 0.7)})`
            });
          }
        }
        
        // æ’æ˜Ÿã®å ´åˆã¯å…‰ã®ãƒ•ãƒ¬ã‚¢ã‚’è¿½åŠ 
        if (type === 'star') {
          this.flares = Array(randInt(3, 6)).fill().map(() => ({
            angle: rand(0, TAU),
            length: rand(1.5, 3) * radius,
            width: rand(0.3, 0.7) * radius,
            phase: rand(0, TAU)
          }));
        }
      }
      
      // ä½ç½®ã‚’æ›´æ–°ï¼ˆãƒªãƒ¼ãƒ—ãƒ•ãƒ­ãƒƒã‚°ç©åˆ†æ³•ï¼‰
      update(dt) {
        // åŠåˆ†ã®ã‚¹ãƒ†ãƒƒãƒ—ã§ã®é€Ÿåº¦æ›´æ–°
        this.vx += this.ax * dt * 0.5 * config.timeScale;
        this.vy += this.ay * dt * 0.5 * config.timeScale;
        
        // ä½ç½®ã®æ›´æ–°
        this.x += this.vx * dt * config.timeScale;
        this.y += this.vy * dt * config.timeScale;
        
        // è»Œé“ã‚’è¨˜éŒ²
        if (config.showTrails && performance.now() % 5 < 1) {
          this.trail.push({x: this.x, y: this.y});
          if (this.trail.length > this.trailMaxLength) {
            this.trail.shift();
          }
        }
        
        // åŠ é€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ç”¨ï¼‰
        this.ax = 0;
        this.ay = 0;
      }
      
      // åŠ›ã‚’åŠ ãˆã‚‹
      applyForce(fx, fy) {
        this.ax += fx / this.m;
        this.ay += fy / this.m;
      }
      
      // æç”»ãƒ¡ã‚½ãƒƒãƒ‰
      draw(ctx) {
        // è»Œé“ã®æç”»
        if (config.showTrails && this.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          
          ctx.strokeStyle = this.isFragment 
            ? 'rgba(150, 150, 150, 0.3)' 
            : `rgba(${parseInt(this.color.slice(1, 3), 16)}, ${parseInt(this.color.slice(3, 5), 16)}, ${parseInt(this.color.slice(5, 7), 16)}, 0.4)`;
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
        
        // æƒ‘æ˜Ÿã‚„æ’æ˜Ÿã®æç”»
        if (this.type === 'star') {
          this.drawStar(ctx);
        } else {
          this.drawPlanet(ctx);
        }
      }
      
      drawPlanet(ctx) {
        // ãƒªãƒ³ã‚°ã‚’æç”»ï¼ˆåœŸæ˜Ÿã®ã‚ˆã†ãªï¼‰
        if (this.rings.length > 0) {
          const angle = Math.atan2(SUN.y() - this.y, SUN.x() - this.x);
          const ringTilt = 0.3; // ãƒªãƒ³ã‚°ã®å‚¾ã
          
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(angle);
          ctx.scale(1, Math.cos(ringTilt)); // å‚¾ãã®åŠ¹æœ
          
          this.rings.forEach(ring => {
            ctx.beginPath();
            ctx.arc(0, 0, ring.outerRadius, 0, TAU);
            ctx.arc(0, 0, ring.innerRadius, 0, TAU, true);
            ctx.fillStyle = ring.color;
            ctx.fill();
          });
          
          ctx.restore();
        }
        
        // æƒ‘æ˜Ÿè¡¨é¢ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        const grad = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.r
        );
        grad.addColorStop(0, lightenColor(this.color, 40));
        grad.addColorStop(0.5, this.color);
        grad.addColorStop(0.8, darkenColor(this.color, 20));
        grad.addColorStop(1, darkenColor(this.color, 40));
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();
        
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆå…‰ã®åå°„ï¼‰
        const sunAngle = Math.atan2(SUN.y() - this.y, SUN.x() - this.x);
        const highlightX = this.x + Math.cos(sunAngle) * (this.r * 0.5);
        const highlightY = this.y + Math.sin(sunAngle) * (this.r * 0.5);
        
        const highlight = ctx.createRadialGradient(
          highlightX, highlightY, 0,
          highlightX, highlightY, this.r * 0.6
        );
        highlight.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = highlight;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();
      }
      
      drawStar(ctx) {
        const t = performance.now() * 0.002;
        const pulseFactor = 1 + 0.08 * Math.sin(t);
        const R = this.r * pulseFactor;
        
        // åŸºæœ¬ã®å…‰ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, R * 2.5);
        g.addColorStop(0, '#fff');
        g.addColorStop(0.2, this.color);
        g.addColorStop(0.7, darkenColor(this.color, 30));
        g.addColorStop(1, 'rgba(0,0,0,0)');
        
        // å…‰ã®ã‚°ãƒ­ãƒ¼åŠ¹æœ
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(this.x, this.y, R * 2.5, 0, TAU);
        ctx.fill();
        
        // æ˜Ÿã®ã‚³ã‚¢
        const coreGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, R);
        coreGradient.addColorStop(0, '#fff');
        coreGradient.addColorStop(0.4, lightenColor(this.color, 50));
        coreGradient.addColorStop(0.8, this.color);
        coreGradient.addColorStop(1, darkenColor(this.color, 10));
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, R, 0, TAU);
        ctx.fill();
        
        // å…‰ã®ãƒ•ãƒ¬ã‚¢ã‚’æç”»
        if (this.flares) {
          const time = performance.now() * 0.001;
          ctx.save();
          ctx.translate(this.x, this.y);
          
          this.flares.forEach(flare => {
            const pulseAmt = 0.7 + 0.3 * Math.sin(time + flare.phase);
            const flareLength = flare.length * pulseAmt;
            
            ctx.save();
            ctx.rotate(flare.angle + time * 0.1); // ã‚†ã£ãã‚Šå›è»¢
            
            const flareGrad = ctx.createLinearGradient(0, 0, flareLength, 0);
            flareGrad.addColorStop(0, lightenColor(this.color, 80));
            flareGrad.addColorStop(0.5, lightenColor(this.color, 30));
            flareGrad.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = flareGrad;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(flareLength, flare.width / 2);
            ctx.lineTo(flareLength, -flare.width / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
          });
          
          ctx.restore();
        }
      }
    }
    
    // è‰²æ“ä½œã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    function lightenColor(hex, percent) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      
      const newR = Math.min(255, r + percent);
      const newG = Math.min(255, g + percent);
      const newB = Math.min(255, b + percent);
      
      return `rgb(${newR}, ${newG}, ${newB})`;
    }
    
    function darkenColor(hex, percent) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      
      const newR = Math.max(0, r - percent);
      const newG = Math.max(0, g - percent);
      const newB = Math.max(0, b - percent);
      
      return `rgb(${newR}, ${newG}, ${newB})`;
    }
    
    // ä¸­å¿ƒã®æ’æ˜Ÿ
    const SUN = {
      x: () => CX + offsetX * scale,
      y: () => CY + offsetY * scale,
      m: 1e7,
      r: 35,
      draw() {
        const t = performance.now() * 0.002;
        const p = 1 + 0.08 * Math.sin(t);
        const R = this.r * p;
        
        // ã‚³ãƒ­ãƒŠåŠ¹æœ
        const corona = ctx.createRadialGradient(this.x(), this.y(), R, this.x(), this.y(), R * 6);
        corona.addColorStop(0, 'rgba(255, 180, 100, 0.2)');
        corona.addColorStop(0.5, 'rgba(255, 150, 50, 0.1)');
        corona.addColorStop(1, 'rgba(255, 120, 50, 0)');
        
        ctx.fillStyle = corona;
        ctx.beginPath();
        ctx.arc(this.x(), this.y(), R * 6, 0, TAU);
        ctx.fill();
        
        // è¡¨é¢ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        const g = ctx.createRadialGradient(this.x(), this.y(), 0, this.x(), this.y(), R);
        g.addColorStop(0, '#fff');
        g.addColorStop(0.4, '#fff6b5');
        g.addColorStop(0.8, '#ffca28');
        g.addColorStop(1, '#ff9800');
        
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(this.x(), this.y(), R, 0, TAU);
        ctx.fill();
        
        // æ’æ˜Ÿãƒ•ãƒ¬ã‚¢
        const flareCount = 6;
        const time = performance.now() * 0.001;
        
        ctx.save();
        ctx.translate(this.x(), this.y(), 0);
        
        for (let i = 0; i < flareCount; i++) {
          const angle = (i / flareCount) * TAU + time * 0.2;
          const flareSize = R * (2 + Math.sin(time * 0.7 + i) * 0.5);
          
          ctx.save();
          ctx.rotate(angle);
          
          const flareGrad = ctx.createLinearGradient(0, 0, flareSize, 0);
          flareGrad.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
          flareGrad.addColorStop(0.5, 'rgba(255, 180, 50, 0.4)');
          flareGrad.addColorStop(1, 'rgba(255, 100, 50, 0)');
          
          ctx.fillStyle = flareGrad;
          ctx.beginPath();
          ctx.moveTo(R * 0.8, 0);
          ctx.lineTo(flareSize, R * 0.4);
          ctx.lineTo(flareSize, -R * 0.4);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
        
        ctx.restore();
      }
    };
    
    function spawnPlanetSet() {
      const data = [
        {n:'æ°´æ˜Ÿ', c:'#a9a9a9', m:3, r:3, d:70},
        {n:'é‡‘æ˜Ÿ', c:'#e0c16c', m:5, r:4, d:110},
        {n:'åœ°çƒ', c:'#4fc3f7', m:6, r:4.5, d:160},
        {n:'ç«æ˜Ÿ', c:'#ff7043', m:3, r:3.5, d:220},
        {n:'æœ¨æ˜Ÿ', c:'#fbc02d', m:190, r:8, d:330, hasBelt: true},
        {n:'åœŸæ˜Ÿ', c:'#d1c4e9', m:95, r:7, d:430, hasBelt: true},
        {n:'å¤©ç‹æ˜Ÿ', c:'#80cbc4', m:14, r:6, d:530},
        {n:'æµ·ç‹æ˜Ÿ', c:'#bcaaa4', m:17, r:5.8, d:620}
      ];
      
      return data.map(p => {
        const ang = rand(0, TAU);
        const x = CX + Math.cos(ang) * p.d;
        const y = CY + Math.sin(ang) * p.d;
        const v = Math.sqrt(G * SUN.m / p.d);
        const vx = -Math.sin(ang) * v;
        const vy = Math.cos(ang) * v;
        
        return new Body({
          name: p.n,
          color: p.c,
          mass: p.m,
          radius: p.r,
          x, y, vx, vy,
          hasBelt: p.hasBelt || false
        });
      });
    }
    
    let bodies = spawnPlanetSet();
    let fragments = []; // ç ´ç‰‡ã‚’åˆ¥ã®ãƒªã‚¹ãƒˆã«ä¿å­˜
    
    /*â€“â€“â€“â€“â€“ FRAGMENTATION â€“â€“â€“â€“â€“*/
    function fragment(b1, b2) {
      const parts = 8; // ã‚ˆã‚Šå¤šãã®ç ´ç‰‡
      const totalMass = b1.m + b2.m;
      const fragMass = totalMass / parts;
      const angleBase = Math.atan2(b1.y - b2.y, b1.x - b2.x);
      const collisionX = (b1.x + b2.x) / 2;
      const collisionY = (b1.y + b2.y) / 2;
      
      // è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      explosions.push({
        x: collisionX,
        y: collisionY,
        radius: Math.max(b1.r, b2.r) * 2,
        alpha: 1.0,
        color: '#fff',
        particles: Array(20).fill().map(() => ({
          x: 0,
          y: 0,
          vx: rand(-3, 3),
          vy: rand(-3, 3),
          size: rand(1, 3),
          life: 1.0
        }))
      });
      
      // ç ´ç‰‡ç”Ÿæˆ
      for (let i = 0; i < parts; i++) {
        const ang = angleBase + rand(-1, 1);
        const speed = rand(1, 4);
        const size = Math.sqrt(fragMass) * rand(0.5, 1.5);
        
        fragments.push(new Body({
          color: rand(0, 1) > 0.5 ? b1.color : b2.color,
          mass: fragMass,
          radius: size,
          x: collisionX,
          y: collisionY,
          vx: Math.cos(ang) * speed,
          vy: Math.sin(ang) * speed
        }));
      }
      
      addLog(`âš ï¸ ${b1.name || 'Fragment'} ã¨ ${b2.name || 'Fragment'} ãŒè¡çªã—ç ´ç‰‡åŒ–`);
    }
    
    /*â€“â€“â€“â€“â€“ EXPLOSION EFFECTS â€“â€“â€“â€“â€“*/
    const explosions = [];
    
    function updateExplosions(dt) {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const exp = explosions[i];
        exp.alpha -= 0.02 * dt;
        exp.radius += 2 * dt;
        
        exp.particles.forEach(p => {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life -= 0.03 * dt;
        });
        
        if (exp.alpha <= 0) {
          explosions.splice(i, 1);
        }
      }
    }
    
    function drawExplosions() {
      explosions.forEach(exp => {
        // çˆ†ç™ºã®ã‚°ãƒ­ãƒ¼åŠ¹æœ
        const glow = ctx.createRadialGradient(
          exp.x, exp.y, 0,
          exp.x, exp.y, exp.radius
        );
        glow.addColorStop(0, `rgba(255, 220, 100, ${exp.alpha * 0.8})`);
        glow.addColorStop(0.4, `rgba(255, 100, 50, ${exp.alpha * 0.5})`);
        glow.addColorStop(1, `rgba(200, 50, 20, 0)`);
        
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, exp.radius, 0, TAU);
        ctx.fill();
        
        // é£›ã³æ•£ã‚‹ç ´ç‰‡
        ctx.save();
        ctx.translate(exp.x, exp.y);
        
        exp.particles.forEach(p => {
          if (p.life > 0) {
            ctx.fillStyle = `rgba(255, 200, 100, ${p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, TAU);
            ctx.fill();
          }
        });
        
        ctx.restore();
      });
    }
    
    /*â€“â€“â€“â€“â€“ IMPROVED PHYSICS SIMULATION â€“â€“â€“â€“â€“*/
    function calculateForces(bodies, fragments) {
      // é‡åŠ›ä½œç”¨ã®è¨ˆç®—ï¼ˆVerletç©åˆ†æ³•ï¼‰
      // ä¸­å¿ƒæ’æ˜Ÿã‹ã‚‰ã®å¼•åŠ›
      const allBodies = [...bodies, ...fragments];
      
      for (let i = 0; i < allBodies.length; i++) {
        const b = allBodies[i];
        
        // ä¸­å¿ƒã®æ’æ˜Ÿã‹ã‚‰ã®é‡åŠ›
        const dx = SUN.x() - b.x;
        const dy = SUN.y() - b.y;
        const distSq = dx * dx + dy * dy;
        const dist = Math.sqrt(distSq);
        
        // è·é›¢ãŒè¿‘ã™ãã‚‹å ´åˆã¯åŠ›ã‚’åˆ¶é™ï¼ˆæ•°å€¤å®‰å®šæ€§ã®ãŸã‚ï¼‰
        const safeDist = Math.max(dist, b.r * 2);
        const f = G * SUN.m / (safeDist * safeDist);
        
        b.applyForce(f * dx / dist, f * dy / dist);
        
        // ä»–ã®å¤©ä½“ã¨ã®ç›¸äº’å¼•åŠ›ã‚’è¨ˆç®—
        for (let j = i + 1; j < allBodies.length; j++) {
          const bj = allBodies[j];
          
          const dx2 = bj.x - b.x;
          const dy2 = bj.y - b.y;
          const distSq2 = dx2 * dx2 + dy2 * dy2;
          const dist2 = Math.sqrt(distSq2);
          
          // è¡çªåˆ¤å®š
          if (dist2 < b.r + bj.r) {
            // ä¸¡æ–¹ã¨ã‚‚åå‰ä»˜ãå¤©ä½“ï¼ˆæƒ‘æ˜Ÿï¼‰ãªã‚‰ç ´ç‰‡åŒ–
            if (b.name && bj.name) {
              fragment(b, bj);
              b.alive = false;
              bj.alive = false;
            } 
            // ç‰‡æ–¹ã ã‘ãŒå‘½åã•ã‚ŒãŸå¤©ä½“ãªã‚‰è³ªé‡ã‚’åˆæˆï¼ˆå°ã•ãªç ´ç‰‡ã®å¸åï¼‰
            else if (b.name) {
              b.m += bj.m;
              b.r = Math.pow(b.r * b.r * b.r + bj.r * bj.r * bj.r, 1/3); // ä½“ç©ä¿å­˜çš„ãªåŠå¾„è¨ˆç®—
              bj.alive = false;
              addLog(`${b.name} ãŒç ´ç‰‡ã‚’å¸å`);
            }
            else if (bj.name) {
              bj.m += b.m;
              bj.r = Math.pow(bj.r * bj.r * bj.r + b.r * b.r * b.r, 1/3);
              b.alive = false;
              addLog(`${bj.name} ãŒç ´ç‰‡ã‚’å¸å`);
            }
            // ä¸¡æ–¹ã¨ã‚‚ç ´ç‰‡ãªã‚‰ã€å¤§ãã„æ–¹ãŒå°ã•ã„æ–¹ã‚’å¸å
            else if (b.m > bj.m) {
              b.m += bj.m;
              b.r = Math.pow(b.r * b.r * b.r + bj.r * bj.r * bj.r, 1/3);
              bj.alive = false;
            } else {
              bj.m += b.m;
              bj.r = Math.pow(bj.r * bj.r * bj.r + b.r * b.r * b.r, 1/3);
              b.alive = false;
            }
            continue;
          }
          
          // é‡åŠ›ã®è¨ˆç®—
          const f2 = G * b.m * bj.m / distSq2;
          const fx = f2 * dx2 / dist2;
          const fy = f2 * dy2 / dist2;
          
          // åŠ›ã®é©ç”¨ï¼ˆä½œç”¨ãƒ»åä½œç”¨ï¼‰
          b.applyForce(fx, fy);
          bj.applyForce(-fx, -fy);
        }
      }
    }
    
    /*â€“â€“â€“â€“â€“ DISTANCE AND CELESTIAL MECHANICS HELPERS â€“â€“â€“â€“â€“*/
    function getOrbitalParameters(body) {
      // è»Œé“è¦ç´ ã®è¨ˆç®— (ç°¡æ˜“ç‰ˆ)
      const dx = body.x - SUN.x();
      const dy = body.y - SUN.y();
      const r = Math.sqrt(dx*dx + dy*dy);
      const v = Math.sqrt(body.vx*body.vx + body.vy*body.vy);
      
      // è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼
      const energy = 0.5 * v*v - G * SUN.m / r;
      
      // è»Œé“ã®ç¨®é¡
      let orbitType;
      if (energy < 0) {
        // è§’é‹å‹•é‡ãƒ™ã‚¯ãƒˆãƒ«
        const angMomentum = r * v;
        
        // é›¢å¿ƒç‡
        const ecc = Math.sqrt(1 + 2 * energy * angMomentum * angMomentum / (G * SUN.m) ** 2);
        
        if (ecc < 0.01) orbitType = "å††è»Œé“";
        else if (ecc < 0.1) orbitType = "ã»ã¼å††è»Œé“";
        else if (ecc < 0.3) orbitType = "æ¥•å††è»Œé“";
        else orbitType = "é«˜é›¢å¿ƒç‡æ¥•å††è»Œé“";
      } else if (Math.abs(energy) < 0.001) {
        orbitType = "æ”¾ç‰©ç·šè»Œé“";
      } else {
        orbitType = "åŒæ›²ç·šè»Œé“";
      }
      
      return {
        distance: r,
        velocity: v,
        orbitType
      };
    }
    
    /*â€“â€“â€“â€“â€“ INTERACTIVE ELEMENTS â€“â€“â€“â€“â€“*/
    const resetBtn = document.getElementById('resetBtn');
    const addPlanetBtn = document.getElementById('addPlanetBtn');
    const addStarBtn = document.getElementById('addStarBtn');
    const toggleTrailBtn = document.getElementById('toggleTrailBtn');
    const timeSpeed = document.getElementById('timeSpeed');
    const timeValue = document.getElementById('timeValue');
    const zoomLevel = document.getElementById('zoomLevel');
    const zoomValue = document.getElementById('zoomValue');
    const tooltip = document.getElementById('tooltip');
    const stats = document.getElementById('stats');
    
    // ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
    resetBtn.addEventListener('click', () => {
      bodies = spawnPlanetSet();
      fragments = [];
      scale = 1;
      offsetX = 0;
      offsetY = 0;
      addLog('ğŸ”„ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
    });
    
    // æƒ‘æ˜Ÿã®è¿½åŠ 
    addPlanetBtn.addEventListener('click', () => {
      const distance = rand(80, config.spawnRadius.planets);
      const angle = rand(0, TAU);
      const x = CX + Math.cos(angle) * distance;
      const y = CY + Math.sin(angle) * distance;
      
      // è»Œé“é€Ÿåº¦ã‚’è¨ˆç®— (å††è»Œé“ç”¨)
      const v = Math.sqrt(G * SUN.m / distance);
      const vx = -Math.sin(angle) * v * rand(0.8, 1.2); // è‹¥å¹²æºã‚‰ãã‚’åŠ ãˆã‚‹
      const vy = Math.cos(angle) * v * rand(0.8, 1.2);
      
      const planetColors = ['#4fc3f7', '#ff7043', '#d1c4e9', '#80cbc4', '#bcaaa4', '#e0c16c', '#a9a9a9'];
      const color = planetColors[Math.floor(rand(0, planetColors.length))];
      
      bodies.push(new Body({
        name: `æƒ‘æ˜Ÿ-${bodies.length + 1}`,
        color,
        mass: rand(2, 20),
        radius: rand(3, 6),
        x, y, vx, vy,
        hasBelt: rand(0, 1) > 0.8
      }));
      
      addLog(`ğŸª æ–°ã—ã„æƒ‘æ˜Ÿã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
    });
    
    // æ’æ˜Ÿã®è¿½åŠ 
    addStarBtn.addEventListener('click', () => {
      const distance = rand(200, config.spawnRadius.planets);
      const angle = rand(0, TAU);
      const x = CX + Math.cos(angle) * distance;
      const y = CY + Math.sin(angle) * distance;
      
      // æ’æ˜Ÿãªã®ã§è»Œé“é€Ÿåº¦ã¯é€šå¸¸ã®æƒ‘æ˜Ÿã‚ˆã‚Šé…ã‚ã«
      const v = Math.sqrt(G * SUN.m / distance) * 0.7;
      const vx = -Math.sin(angle) * v;
      const vy = Math.cos(angle) * v;
      
      const starColors = ['#ff9800', '#ffeb3b', '#ffc107', '#03a9f4', '#f5f5f5'];
      const color = starColors[Math.floor(rand(0, starColors.length))];
      
      bodies.push(new Body({
        name: `æ’æ˜Ÿ-${bodies.length + 1}`,
        color,
        mass: rand(500, 2000),
        radius: rand(15, 25),
        x, y, vx, vy,
        type: 'star'
      }));
      
      addLog(`â­ æ–°ã—ã„æ’æ˜Ÿã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
    });
    
    // è»Œé“è¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ
    toggleTrailBtn.addEventListener('click', () => {
      config.showTrails = !config.showTrails;
      toggleTrailBtn.textContent = config.showTrails ? 'è»Œé“éè¡¨ç¤º' : 'è»Œé“è¡¨ç¤º';
      addLog(`${config.showTrails ? 'âœ“' : 'âœ—'} è»Œé“è¡¨ç¤ºã‚’${config.showTrails ? 'ã‚ªãƒ³' : 'ã‚ªãƒ•'}ã«ã—ã¾ã—ãŸ`);
    });
    
    // æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
    timeSpeed.addEventListener('input', () => {
      config.timeScale = parseFloat(timeSpeed.value);
      timeValue.textContent = `${config.timeScale.toFixed(1)}x`;
    });
    
    // ã‚ºãƒ¼ãƒ ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
    zoomLevel.addEventListener('input', () => {
      scale = parseFloat(zoomLevel.value);
      zoomValue.textContent = `${scale.toFixed(1)}x`;
    });
    
    // ãƒã‚¦ã‚¹æ“ä½œï¼ˆãƒ‘ãƒ³ã€ã‚ºãƒ¼ãƒ ã€ãƒ›ãƒãƒ¼ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ï¼‰
    let hoveredBody = null;
    
    cvs.addEventListener('mousedown', (e) => {
      dragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    
    cvs.addEventListener('mouseup', () => {
      dragging = false;
    });
    
    cvs.addEventListener('mouseleave', () => {
      dragging = false;
      hoveredBody = null;
      tooltip.style.opacity = 0;
    });
    
    cvs.addEventListener('mousemove', (e) => {
      if (dragging) {
        // è¦–ç‚¹ã®ãƒ‘ãƒ³
        offsetX += (e.clientX - lastMouseX) / scale;
        offsetY += (e.clientY - lastMouseY) / scale;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
      
      // ãƒã‚¦ã‚¹ä½ç½®ã‚’ä¸–ç•Œåº§æ¨™ã«å¤‰æ›
      const mouseX = (e.clientX - CX) / scale - offsetX;
      const mouseY = (e.clientY - CY) / scale - offsetY;
      
      // å¤©ä½“ã®æ¤œå‡ºï¼ˆãƒ›ãƒãƒ¼ï¼‰
      let closest = null;
      let minDist = Infinity;
      
      for (const body of bodies) {
        const dx = body.x - (CX + mouseX * scale);
        const dy = body.y - (CY + mouseY * scale);
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < Math.max(body.r * 2, 20) && dist < minDist) {
          minDist = dist;
          closest = body;
        }
      }
      
      // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®æ›´æ–°
      if (closest) {
        hoveredBody = closest;
        tooltip.style.opacity = 1;
        tooltip.style.left = `${e.clientX + 15}px`;
        tooltip.style.top = `${e.clientY + 15}px`;
        
        const orbital = getOrbitalParameters(closest);
        tooltip.innerHTML = `
          <strong>${closest.name || 'ç ´ç‰‡'}</strong><br>
          è³ªé‡: ${closest.m.toFixed(1)}<br>
          åŠå¾„: ${closest.r.toFixed(1)}<br>
          è·é›¢: ${orbital.distance.toFixed(0)}<br>
          é€Ÿåº¦: ${orbital.velocity.toFixed(2)}<br>
          è»Œé“: ${orbital.orbitType}
        `;
      } else {
        hoveredBody = null;
        tooltip.style.opacity = 0;
      }
    });
    
    // ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã®ã‚ºãƒ¼ãƒ 
    cvs.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      scale *= zoomFactor;
      
      // ç¯„å›²ã‚’åˆ¶é™
      scale = Math.max(0.2, Math.min(3, scale));
      
      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚‚æ›´æ–°
      zoomLevel.value = scale;
      zoomValue.textContent = `${scale.toFixed(1)}x`;
    });
    
    // å¤©ä½“ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠãƒ»è¿½è·¡
    let selectedBody = null;
    
    cvs.addEventListener('click', (e) => {
      if (hoveredBody) {
        if (selectedBody === hoveredBody) {
          selectedBody = null;
          addLog(`è¿½è·¡ã‚’è§£é™¤ã—ã¾ã—ãŸ`);
        } else {
          selectedBody = hoveredBody;
          addLog(`${selectedBody.name || 'ç ´ç‰‡'} ã‚’è¿½è·¡ä¸­`);
        }
      }
    });
    
    // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ–°è¦å¤©ä½“è¿½åŠ 
    cvs.addEventListener('dblclick', (e) => {
      const worldX = (e.clientX - CX) / scale - offsetX;
      const worldY = (e.clientY - CY) / scale - offsetY;
      
      // ãƒã‚¦ã‚¹ä½ç½®ã«å¤©ä½“ã‚’è¿½åŠ 
      const x = CX + worldX * scale;
      const y = CY + worldY * scale;
      
      const dx = x - SUN.x();
      const dy = y - SUN.y();
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // è»Œé“é€Ÿåº¦ã®è¨ˆç®—
      const angle = Math.atan2(dy, dx);
      const v = Math.sqrt(G * SUN.m / distance);
      
      // æ¥ç·šæ–¹å‘ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
      const vx = -Math.sin(angle) * v;
      const vy = Math.cos(angle) * v;
      
      bodies.push(new Body({
        name: `æƒ‘æ˜Ÿ-${bodies.length + 1}`,
        color: `hsl(${rand(0, 360)}, 70%, 60%)`,
        mass: rand(2, 30),
        radius: rand(3, 7),
        x, y, vx, vy
      }));
      
      addLog(`ğŸª ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æƒ‘æ˜Ÿã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
    });
    
    // â˜…â˜…â˜… ã“ã“ã‹ã‚‰æµã‚Œæ˜Ÿã®å®Ÿè£…ã‚’è¿½åŠ  â˜…â˜…â˜…
    
    // æµã‚Œæ˜Ÿã®ãƒªã‚¹ãƒˆ
    const meteors = [];
    
    // æµã‚Œæ˜Ÿã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
    function spawnMeteor() {
      // ç”»é¢ä¸Šéƒ¨ã®ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã‹ã‚‰æ–œã‚ä¸‹ã«æµã‚Œã‚‹
      const startX = rand(0, W);
      const startY = rand(-100, 0);
      const angle = rand(Math.PI * 0.65, Math.PI * 0.95); // æ–œã‚ä¸‹å‘ã
      const speed = rand(12, 22);
      meteors.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        len: rand(80, 180),
        alpha: 1.0,
        width: rand(2, 3.5),
        color: 'rgba(255,255,200,'
      });
    }
    
    // æµã‚Œæ˜Ÿã‚’æç”»ãƒ»æ›´æ–°
    function updateAndDrawMeteors(dt) {
      for (let i = meteors.length - 1; i >= 0; i--) {
        const m = meteors[i];
        m.x += m.vx * dt;
        m.y += m.vy * dt;
        m.alpha -= 0.012 * dt;
        if (m.alpha <= 0 || m.x < -200 || m.x > W + 200 || m.y > H + 200) {
          meteors.splice(i, 1);
          continue;
        }
        // æç”»
        ctx.save();
        ctx.globalAlpha = m.alpha;
        ctx.strokeStyle = m.color + m.alpha + ')';
        ctx.lineWidth = m.width;
        ctx.beginPath();
        ctx.moveTo(m.x, m.y);
        ctx.lineTo(m.x - m.vx * (m.len / 20), m.y - m.vy * (m.len / 20));
        ctx.stroke();
        ctx.restore();
      }
    }
    
    // ä¸€å®šç¢ºç‡ã§æµã‚Œæ˜Ÿã‚’ç™ºç”Ÿã•ã›ã‚‹
    setInterval(() => {
      if (Math.random() < 0.4) spawnMeteor();
    }, 900);
    
    // â˜…â˜…â˜… ã“ã“ã¾ã§æµã‚Œæ˜Ÿã®å®Ÿè£…ã‚’è¿½åŠ  â˜…â˜…â˜…
    
    /*â€“â€“â€“â€“â€“ MAIN LOOP â€“â€“â€“â€“â€“*/
    let last = performance.now();
    function loop(now) {
      const dt = Math.min((now - last) / 16, 3);
      last = now;
      
      ctx.clearRect(0, 0, W, H);
      
      // èƒŒæ™¯
      drawBackground();
      drawBackgroundStars(now);
      
      // æµã‚Œæ˜Ÿã‚’æç”»
      updateAndDrawMeteors(dt);
      
      drawGalaxyDisk(now, dt);
      
      // å¤ªé™½ï¼ˆå¸¸ã«ä¸­å¿ƒï¼‰
      ctx.save();
      ctx.translate(offsetX * scale, offsetY * scale);
      SUN.draw();
      ctx.restore();
      
      // ç‰©ç†è¨ˆç®—
      calculateForces(bodies, fragments);
      
      // ä½ç½®æ›´æ–°
      [...bodies, ...fragments].forEach(b => b.update(dt));
      
      // ç ´ç‰‡ã‚„çˆ†ç™ºã®æ›´æ–°
      updateExplosions(dt);
      
      // è¿½è·¡ä¸­ã®å¤©ä½“ãŒã‚ã‚‹å ´åˆã¯ãã®ä½ç½®ã«è¦–ç‚¹ã‚’åˆã‚ã›ã‚‹
      if (selectedBody && selectedBody.alive) {
        const targetX = -(selectedBody.x - CX);
        const targetY = -(selectedBody.y - CY);
        offsetX = targetX / scale;
        offsetY = targetY / scale;
      }
      
      // æç”»
      ctx.save();
      ctx.translate(CX, CY);
      ctx.scale(scale, scale);
      ctx.translate(offsetX, offsetY);
      
      // å…ˆã«çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æç”»
      drawExplosions();
      
      // å¤©ä½“æç”»
      [...bodies, ...fragments].forEach(b => {
        if (b.alive) b.draw(ctx);
      });
      
      ctx.restore();
      
      // ç”Ÿå­˜ã—ã¦ã„ãªã„å¤©ä½“ã®å‰Šé™¤
      bodies = bodies.filter(b => b.alive);
      fragments = fragments.filter(b => b.alive);
      
      // ç”»é¢å¤–ã«å‡ºãŸç ´ç‰‡ã‚’å‰Šé™¤ï¼ˆæœ€é©åŒ–ï¼‰
      const margin = 2000; // ä½™è£•ã‚’æŒãŸã›ã‚‹
      fragments = fragments.filter(f => {
        const dx = f.x - SUN.x();
        const dy = f.y - SUN.y();
        return dx * dx + dy * dy < margin * margin;
      });
      
      // çµ±è¨ˆæƒ…å ±ã®è¡¨ç¤º
      stats.textContent = `å¤©ä½“æ•°: ${bodies.length} | ç ´ç‰‡æ•°: ${fragments.length} | FPS: ${(1000 / dt / 16).toFixed(0)}`;
      
      requestAnimationFrame(loop);
    }
    
    addLog('ğŸŒŒ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ - ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³ã€ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ');
    requestAnimationFrame(loop);
  </script>
</body>
</html>
