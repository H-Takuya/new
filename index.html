<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>高度な銀河系シミュレーター ✦ N‑Body & リアルタイム物理演算</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    
    #controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      display: flex;
      gap: 10px;
      background: rgba(20, 20, 30, 0.7);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(100, 120, 255, 0.3);
      box-shadow: 0 0 15px rgba(70, 130, 240, 0.3);
      pointer-events: all;
    }
    
    button {
      background: rgba(60, 80, 170, 0.8);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }
    
    button:hover {
      background: rgba(80, 100, 220, 0.9);
      box-shadow: 0 0 8px rgba(120, 170, 255, 0.6);
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #cce;
    }
    
    input[type="range"] {
      accent-color: rgb(80, 120, 255);
    }
    
    #log {
      position: fixed;
      top: 10px;
      right: 10px;
      max-width: 340px;
      max-height: 90vh;
      overflow-y: auto;
      font: 12px/1.4 monospace;
      background: rgba(10, 10, 30, .7);
      color: #cce;
      border: 1px solid rgba(100, 120, 255, 0.3);
      padding: 8px 12px;
      border-radius: 8px;
      white-space: pre-line;
      pointer-events: none;
      box-shadow: 0 0 15px rgba(70, 130, 240, 0.3);
      transition: opacity 0.3s;
    }
    
    #log::-webkit-scrollbar {
      width: 5px;
    }
    
    #log::-webkit-scrollbar-thumb {
      background: rgba(100, 150, 255, 0.4);
      border-radius: 5px;
    }
    
    #stats {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(10, 10, 30, .7);
      color: #cce;
      border: 1px solid rgba(100, 120, 255, 0.3);
      padding: 8px 12px;
      border-radius: 8px;
      font: 12px/1.4 monospace;
      pointer-events: none;
      box-shadow: 0 0 15px rgba(70, 130, 240, 0.3);
    }
    
    .tooltip {
      position: absolute;
      background: rgba(20, 30, 60, 0.85);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      border: 1px solid rgba(100, 150, 255, 0.4);
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="sim"></canvas>
  <div id="ui">
    <div id="controls">
      <button id="resetBtn">リセット</button>
      <button id="addPlanetBtn">惑星追加</button>
      <button id="addStarBtn">恒星追加</button>
      <button id="toggleTrailBtn">軌道表示</button>
      <div class="slider-container">
        <span>時間速度:</span>
        <input type="range" id="timeSpeed" min="0.1" max="3" step="0.1" value="1">
        <span id="timeValue">1.0x</span>
      </div>
      <div class="slider-container">
        <span>ズーム:</span>
        <input type="range" id="zoomLevel" min="0.2" max="2" step="0.1" value="1">
        <span id="zoomValue">1.0x</span>
      </div>
    </div>
  </div>
  <div id="log"></div>
  <div id="stats"></div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    /*––––– CANVAS SETUP –––––*/
    const cvs = document.getElementById('sim');
    const ctx = cvs.getContext('2d');
    const DPR = window.devicePixelRatio || 1;
    let W, H, CX, CY;
    let scale = 1;
    let offsetX = 0, offsetY = 0; 
    let dragging = false;
    let lastMouseX, lastMouseY;
    
    function resize() {
      W = innerWidth;
      H = innerHeight;
      CX = W / 2;
      CY = H / 2;
      cvs.width = W * DPR;
      cvs.height = H * DPR;
      cvs.style.width = W + 'px';
      cvs.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    
    resize();
    addEventListener('resize', resize);
    
    const TAU = Math.PI * 2;
    const rand = (a, b) => Math.random() * (b - a) + a;
    const randInt = (a, b) => Math.floor(rand(a, b + 1));
    
    /*––––– CONFIG PARAMETERS –––––*/
    let config = {
      timeScale: 1,
      showTrails: true,
      zoomLevel: 1,
      gravitationalConstant: 0.00020,
      diskRotationSpeed: 0.0005,
      particleCount: {
        stars: 700,
        diskParticles: 2200,
        dustParticles: 900
      },
      spawnRadius: {
        planets: 800
      },
      colors: {
        stars: ['#FFFFFF', '#F8F7FF', '#EEEEFF', '#FFEECC', '#FFF5CC']
      }
    };

    /*––––– LOG PANEL –––––*/
    const logEl = document.getElementById('log');
    const logs = [];
    function addLog(msg) {
      const t = new Date().toLocaleTimeString('ja-JP', { hour12: false });
      logs.unshift(`[${t}] ${msg}`);
      if (logs.length > 60) logs.pop();
      logEl.textContent = logs.join('\n');
      logEl.scrollTop = 0;
    }
    
    /*––––– BACKGROUND VISUALS –––––*/
    // Background gradient
    function drawBackground() {
      const gradient = ctx.createRadialGradient(CX, CY, 0, CX, CY, Math.max(CX, CY) * 1.5);
      gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
      gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
      gradient.addColorStop(1, 'rgba(5, 5, 15, 1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H);
    }
    
    // Distant stars with varying sizes, colors and brightness
    const bgStars = Array.from({ length: config.particleCount.stars }, () => ({
      x: rand(0, 1),
      y: rand(0, 1),
      r: rand(0.2, 1.8),
      a: rand(0.3, 0.95),
      color: config.colors.stars[randInt(0, config.colors.stars.length - 1)],
      ph: rand(0, TAU),
      s: rand(0.2, 1.2),
      twinkle: rand(0.01, 0.05)
    }));
    
    function drawBackgroundStars(time) {
      ctx.save();
      bgStars.forEach(s => {
        const a = s.a * (0.6 + 0.4 * Math.sin(time * 0.001 * s.s + s.ph));
        const size = s.r * (0.8 + 0.2 * Math.sin(time * s.twinkle + s.ph));
        
        // Star glow
        const glow = ctx.createRadialGradient(
          s.x * W, s.y * H, 0,
          s.x * W, s.y * H, size * 4
        );
        glow.addColorStop(0, s.color);
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        
        ctx.globalAlpha = a * 0.3;
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(s.x * W, s.y * H, size * 4, 0, TAU);
        ctx.fill();
        
        // Star core
        ctx.globalAlpha = a;
        ctx.fillStyle = s.color;
        ctx.beginPath();
        ctx.arc(s.x * W, s.y * H, size, 0, TAU);
        ctx.fill();
      });
      ctx.restore();
    }
    
    /*––––– GALAXY DISK –––––*/
    const disk = [];
    const ARMS = 5; // 腕の数を増やす
    const STAR_PER_ARM = config.particleCount.diskParticles / ARMS; 
    
    // 密度波パターンを使って、より自然なスパイラルを作成
    for (let a = 0; a < ARMS; a++) {
      for (let i = 0; i < STAR_PER_ARM; i++) {
        const r = Math.pow(i / STAR_PER_ARM, 0.8) * 900 * rand(0.85, 1.15); // より非線形な分布
        const armWidth = 40 + r * 0.08; // 距離に応じて腕の幅が広がる
        const th = a * (TAU / ARMS) + r * 0.004 * Math.log(r + 50) + rand(-0.2, 0.2) * Math.exp(-r/500);
        
        // 腕の中での位置（中心線からの距離）
        const fromCenter = rand(-1, 1) * armWidth;
        const perpAng = th + Math.PI/2;
        const xOffset = Math.cos(perpAng) * fromCenter;
        const yOffset = Math.sin(perpAng) * fromCenter;
        
        // より自然な分布のために指数関数的衰退を使用
        const brightness = Math.exp(-r / 700) * rand(0.7, 1);
        
        // 色相のグラデーション - 内側は黄色っぽく、外側は青っぽく
        const hue = r < 300 ? rand(40, 60) : rand(180, 260);
        
        disk.push({
          r,
          th,
          x: Math.cos(th) * r + xOffset,
          y: Math.sin(th) * r + yOffset,
          sz: rand(0.4, 2.0) * brightness,
          h: hue,
          s: rand(60, 90),
          l: rand(70, 90),
          spd: config.diskRotationSpeed / (0.2 + Math.sqrt(r) * 0.01),
          brightness,
          offset: {x: xOffset, y: yOffset}
        });
      }
    }
    
    // 塵/ガスの粒子を追加
    const dust = [];
    for (let i = 0; i < config.particleCount.dustParticles; i++) {
      const r = Math.pow(rand(0, 1), 0.6) * 1000 * rand(0.5, 1.2);
      const th = rand(0, TAU);
      const density = Math.exp(-r / 500);
      
      dust.push({
        r,
        th,
        x: Math.cos(th) * r,
        y: Math.sin(th) * r,
        opacity: rand(0.01, 0.1) * density,
        color: rand(0, 1) > 0.5 ? 'rgba(100, 120, 255, ' : 'rgba(255, 200, 120, ',
        size: rand(60, 160) * density,
        spd: config.diskRotationSpeed / (0.4 + Math.sqrt(r) * 0.01)
      });
    }
    
    function drawGalaxyDisk(time, dt) {
      ctx.save();
      ctx.translate(CX + offsetX, CY + offsetY);
      ctx.scale(scale, scale);
      
      // まず塵/ガスを描画（低い透明度で重ねる）
      dust.forEach(d => {
        d.th += d.spd * dt * config.timeScale;
        d.x = Math.cos(d.th) * d.r;
        d.y = Math.sin(d.th) * d.r;
        
        ctx.globalAlpha = d.opacity;
        const gradient = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, d.size);
        gradient.addColorStop(0, d.color + '0.4)');
        gradient.addColorStop(1, d.color + '0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.size, 0, TAU);
        ctx.fill();
      });
      
      // 次に星を描画
      disk.forEach(s => {
        s.th += s.spd * dt * config.timeScale;
        s.x = Math.cos(s.th) * s.r + s.offset.x;
        s.y = Math.sin(s.th) * s.r + s.offset.y;
        
        // 星の明るさにアニメーションを追加
        const flickerAmt = 0.85 + 0.15 * Math.sin(time * 0.001 + s.r);
        const starAlpha = s.brightness * flickerAmt;
        
        // 星自体を描画
        ctx.globalAlpha = starAlpha;
        ctx.fillStyle = `hsl(${s.h}, ${s.s}%, ${s.l}%)`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.sz, 0, TAU);
        ctx.fill();
        
        // 星の周りに光るハロー効果を追加
        if (s.sz > 1.4) {
          const glow = ctx.createRadialGradient(
            s.x, s.y, 0,
            s.x, s.y, s.sz * 3
          );
          glow.addColorStop(0, `hsla(${s.h}, ${s.s}%, ${s.l}%, 0.8)`);
          glow.addColorStop(1, 'rgba(0,0,0,0)');
          
          ctx.globalAlpha = starAlpha * 0.4;
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.sz * 3, 0, TAU);
          ctx.fill();
        }
      });
      
      ctx.restore();
    }
    
    /*––––– PHYSICS SYSTEM –––––*/
    // 重力定数 G
    const G = config.gravitationalConstant;
    
    // 天体クラス
    class Body {
      constructor({name, color, mass, radius, x, y, vx, vy, type='planet', hasBelt = false}) {
        this.name = name;
        this.color = color;
        this.m = mass;
        this.r = radius;
        this.x = x;
        this.y = y;
        this.vx = vx || 0;
        this.vy = vy || 0;
        this.ax = 0;
        this.ay = 0;
        this.type = type;
        this.isFragment = !name;
        this.trail = [];
        this.trailMaxLength = 100;
        this.alive = true;
        this.created = Date.now();
        this.rings = [];
        
        // リングがある場合は生成
        if (hasBelt) {
          const ringCount = randInt(1, 3);
          for (let i = 0; i < ringCount; i++) {
            this.rings.push({
              innerRadius: this.r * (1.6 + i * 0.8) * rand(0.9, 1.1),
              outerRadius: this.r * (2.2 + i * 0.8) * rand(0.9, 1.1),
              color: `hsla(${rand(20, 60)}, ${rand(40, 70)}%, ${rand(70, 90)}%, ${rand(0.4, 0.7)})`
            });
          }
        }
        
        // 恒星の場合は光のフレアを追加
        if (type === 'star') {
          this.flares = Array(randInt(3, 6)).fill().map(() => ({
            angle: rand(0, TAU),
            length: rand(1.5, 3) * radius,
            width: rand(0.3, 0.7) * radius,
            phase: rand(0, TAU)
          }));
        }
      }
      
      // 位置を更新（リープフロッグ積分法）
      update(dt) {
        // 半分のステップでの速度更新
        this.vx += this.ax * dt * 0.5 * config.timeScale;
        this.vy += this.ay * dt * 0.5 * config.timeScale;
        
        // 位置の更新
        this.x += this.vx * dt * config.timeScale;
        this.y += this.vy * dt * config.timeScale;
        
        // 軌道を記録
        if (config.showTrails && performance.now() % 5 < 1) {
          this.trail.push({x: this.x, y: this.y});
          if (this.trail.length > this.trailMaxLength) {
            this.trail.shift();
          }
        }
        
        // 加速度をリセット（次のステップ用）
        this.ax = 0;
        this.ay = 0;
      }
      
      // 力を加える
      applyForce(fx, fy) {
        this.ax += fx / this.m;
        this.ay += fy / this.m;
      }
      
      // 描画メソッド
      draw(ctx) {
        // 軌道の描画
        if (config.showTrails && this.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          
          for (let i = 1; i < this.trail.length; i++) {
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
          }
          
          ctx.strokeStyle = this.isFragment 
            ? 'rgba(150, 150, 150, 0.3)' 
            : `rgba(${parseInt(this.color.slice(1, 3), 16)}, ${parseInt(this.color.slice(3, 5), 16)}, ${parseInt(this.color.slice(5, 7), 16)}, 0.4)`;
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
        
        // 惑星や恒星の描画
        if (this.type === 'star') {
          this.drawStar(ctx);
        } else {
          this.drawPlanet(ctx);
        }
      }
      
      drawPlanet(ctx) {
        // リングを描画（土星のような）
        if (this.rings.length > 0) {
          const angle = Math.atan2(SUN.y() - this.y, SUN.x() - this.x);
          const ringTilt = 0.3; // リングの傾き
          
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(angle);
          ctx.scale(1, Math.cos(ringTilt)); // 傾きの効果
          
          this.rings.forEach(ring => {
            ctx.beginPath();
            ctx.arc(0, 0, ring.outerRadius, 0, TAU);
            ctx.arc(0, 0, ring.innerRadius, 0, TAU, true);
            ctx.fillStyle = ring.color;
            ctx.fill();
          });
          
          ctx.restore();
        }
        
        // 惑星表面のグラデーション
        const grad = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.r
        );
        grad.addColorStop(0, lightenColor(this.color, 40));
        grad.addColorStop(0.5, this.color);
        grad.addColorStop(0.8, darkenColor(this.color, 20));
        grad.addColorStop(1, darkenColor(this.color, 40));
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();
        
        // ハイライト（光の反射）
        const sunAngle = Math.atan2(SUN.y() - this.y, SUN.x() - this.x);
        const highlightX = this.x + Math.cos(sunAngle) * (this.r * 0.5);
        const highlightY = this.y + Math.sin(sunAngle) * (this.r * 0.5);
        
        const highlight = ctx.createRadialGradient(
          highlightX, highlightY, 0,
          highlightX, highlightY, this.r * 0.6
        );
        highlight.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = highlight;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();
      }
      
      drawStar(ctx) {
        const t = performance.now() * 0.002;
        const pulseFactor = 1 + 0.08 * Math.sin(t);
        const R = this.r * pulseFactor;
        
        // 基本の光のグラデーション
        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, R * 2.5);
        g.addColorStop(0, '#fff');
        g.addColorStop(0.2, this.color);
        g.addColorStop(0.7, darkenColor(this.color, 30));
        g.addColorStop(1, 'rgba(0,0,0,0)');
        
        // 光のグロー効果
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(this.x, this.y, R * 2.5, 0, TAU);
        ctx.fill();
        
        // 星のコア
        const coreGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, R);
        coreGradient.addColorStop(0, '#fff');
        coreGradient.addColorStop(0.4, lightenColor(this.color, 50));
        coreGradient.addColorStop(0.8, this.color);
        coreGradient.addColorStop(1, darkenColor(this.color, 10));
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, R, 0, TAU);
        ctx.fill();
        
        // 光のフレアを描画
        if (this.flares) {
          const time = performance.now() * 0.001;
          ctx.save();
          ctx.translate(this.x, this.y);
          
          this.flares.forEach(flare => {
            const pulseAmt = 0.7 + 0.3 * Math.sin(time + flare.phase);
            const flareLength = flare.length * pulseAmt;
            
            ctx.save();
            ctx.rotate(flare.angle + time * 0.1); // ゆっくり回転
            
            const flareGrad = ctx.createLinearGradient(0, 0, flareLength, 0);
            flareGrad.addColorStop(0, lightenColor(this.color, 80));
            flareGrad.addColorStop(0.5, lightenColor(this.color, 30));
            flareGrad.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = flareGrad;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(flareLength, flare.width / 2);
            ctx.lineTo(flareLength, -flare.width / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
          });
          
          ctx.restore();
        }
      }
    }
    
    // 色操作のヘルパー関数
    function lightenColor(hex, percent) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      
      const newR = Math.min(255, r + percent);
      const newG = Math.min(255, g + percent);
      const newB = Math.min(255, b + percent);
      
      return `rgb(${newR}, ${newG}, ${newB})`;
    }
    
    function darkenColor(hex, percent) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      
      const newR = Math.max(0, r - percent);
      const newG = Math.max(0, g - percent);
      const newB = Math.max(0, b - percent);
      
      return `rgb(${newR}, ${newG}, ${newB})`;
    }
    
    // 中心の恒星
    const SUN = {
      x: () => CX + offsetX * scale,
      y: () => CY + offsetY * scale,
      m: 1e7,
      r: 35,
      draw() {
        const t = performance.now() * 0.002;
        const p = 1 + 0.08 * Math.sin(t);
        const R = this.r * p;
        
        // コロナ効果
        const corona = ctx.createRadialGradient(this.x(), this.y(), R, this.x(), this.y(), R * 6);
        corona.addColorStop(0, 'rgba(255, 180, 100, 0.2)');
        corona.addColorStop(0.5, 'rgba(255, 150, 50, 0.1)');
        corona.addColorStop(1, 'rgba(255, 120, 50, 0)');
        
        ctx.fillStyle = corona;
        ctx.beginPath();
        ctx.arc(this.x(), this.y(), R * 6, 0, TAU);
        ctx.fill();
        
        // 表面のグラデーション
        const g = ctx.createRadialGradient(this.x(), this.y(), 0, this.x(), this.y(), R);
        g.addColorStop(0, '#fff');
        g.addColorStop(0.4, '#fff6b5');
        g.addColorStop(0.8, '#ffca28');
        g.addColorStop(1, '#ff9800');
        
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(this.x(), this.y(), R, 0, TAU);
        ctx.fill();
        
        // 恒星フレア
        const flareCount = 6;
        const time = performance.now() * 0.001;
        
        ctx.save();
        ctx.translate
