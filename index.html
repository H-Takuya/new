<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>éŠ€æ²³ç³»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆæ¼”å‡ºãƒ»è¦ç´ å¼·åŒ–ç‰ˆï¼‰</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      /* èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¯Nebulaã§æç”»ã™ã‚‹ãŸã‚å‰Šé™¤ */
      /* background: radial-gradient(circle at center, #050505 0%, #0a0a10 70%, #101015 100%); */
      cursor: crosshair; /* ã‚«ãƒ¼ã‚½ãƒ«å¤‰æ›´ */
    }
    #timestamp {
      position: fixed;
      top: 15px;
      left: 15px;
      color: #e0e0e0;
      font-size: 18px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 15px;
      border-radius: 5px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      z-index: 10; /* UIãŒæ‰‹å‰ã«æ¥ã‚‹ã‚ˆã†ã« */
    }
    #history {
      position: fixed;
      top: 15px;
      right: 15px;
      max-height: calc(100% - 30px);
      overflow-y: auto;
      font-size: 12px;
      background: rgba(10, 10, 20, 0.6); /* å°‘ã—æ¿ƒã */
      padding: 10px 15px;
      border-radius: 5px;
      white-space: pre-line;
      color: rgba(200, 200, 255, 0.8); /* å°‘ã—æ˜ã‚‹ã */
      font-style: normal;
      border: 1px solid rgba(255, 255, 255, 0.15); /* å°‘ã—æ¿ƒã */
      max-width: 320px; /* å°‘ã—åºƒã */
      z-index: 10; /* UIãŒæ‰‹å‰ã«æ¥ã‚‹ã‚ˆã†ã« */
    }
    #history::-webkit-scrollbar {
      width: 5px;
    }
    #history::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.3);
      border-radius: 5px;
    }
    #history::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.3);
      border-radius: 5px;
    }
    #history::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.5);
    }
    /* ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ (ä»»æ„) */
    #zoom-indicator {
        position: fixed;
        bottom: 15px;
        left: 15px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 3px;
        z-index: 10;
    }
  </style>
</head>
<body>
  <div id="timestamp">Loading...</div>
  <div id="history">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å±¥æ­´</div>
  <div id="zoom-indicator">Zoom: 1.0x</div> <canvas id="sim"></canvas>

  <script>
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    const timestampEl = document.getElementById("timestamp");
    const historyEl = document.getElementById("history");
    const zoomIndicatorEl = document.getElementById("zoom-indicator"); // ã‚ºãƒ¼ãƒ è¡¨ç¤ºç”¨è¦ç´ 

    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    let centerX = canvasWidth / 2;
    let centerY = canvasHeight / 2;

    const startDate = new Date("2025-01-01T00:00:00");
    let elapsedDays = 0;
    let history = ["ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹: " + startDate.toLocaleString()];
    historyEl.textContent = history.join('\n');

    // --- ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š ---
    const FADE_SPEED = 0.01;
    const TIME_SCALE = 0.05; // æ™‚é–“çµŒéé€Ÿåº¦
    const MAX_HISTORY = 50; // å±¥æ­´ã®æœ€å¤§æ•°
    const STAR_COUNT = 600; // æ˜Ÿã®æ•°
    const ASTEROID_COUNT = 150; // å°æƒ‘æ˜Ÿã®æ•°
    const PARTICLE_COUNT = 50; // çˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ•°
    const PARTICLE_LIFESPAN = 60; // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
    const MIN_ZOOM = 0.3; // æœ€å°ã‚ºãƒ¼ãƒ å€ç‡
    const MAX_ZOOM = 3.0; // æœ€å¤§ã‚ºãƒ¼ãƒ å€ç‡
    const ZOOM_SPEED = 0.001; // ã‚ºãƒ¼ãƒ æ„Ÿåº¦

    // --- çŠ¶æ…‹å¤‰æ•° ---
    let stars = [];
    let planets = [];
    let asteroids = [];
    let particles = [];
    let clickEffects = []; // ã‚¯ãƒªãƒƒã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
    let scale = 1.0; // ç¾åœ¨ã®ã‚ºãƒ¼ãƒ å€ç‡
    let targetScale = 1.0; // ç›®æ¨™ã®ã‚ºãƒ¼ãƒ å€ç‡
    let isDragging = false; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãƒ•ãƒ©ã‚° (å°†æ¥çš„ãªè¦–ç‚¹ç§»å‹•ç”¨)
    let lastMouseX, lastMouseY; // å‰å›ã®ãƒã‚¦ã‚¹åº§æ¨™ (å°†æ¥çš„ãªè¦–ç‚¹ç§»å‹•ç”¨)
    // let viewOffsetX = 0, viewOffsetY = 0; // è¦–ç‚¹ã‚ªãƒ•ã‚»ãƒƒãƒˆ (å°†æ¥çš„ãªè¦–ç‚¹ç§»å‹•ç”¨)

    // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå®šç¾© ---
    let blackHole = { /* ... (å‰å›åŒæ§˜) ... */
        x: 0, y: 0, radius: 50, active: false, angle: 0, opacity: 0,
        fadingOut: false, timeoutId: null, attractionRadius: 250, pullStrength: 0.0008
    };
    let spaceship = { /* ... (å‰å›åŒæ§˜) ... */
        x: centerX, y: centerY, vx: 0, vy: 0, active: false
    };
    let meteor = { /* ... (å‰å›åŒæ§˜) ... */
        x: -100, y: Math.random() * canvasHeight, speed: 5 + Math.random() * 5,
        radius: 5 + Math.random() * 10, active: true,
        angle: Math.atan2(Math.random() * canvasHeight - canvasHeight/2, canvasWidth), tail: []
    };
    const planetBaseData = [ // æƒ‘æ˜Ÿã®åŸºæœ¬ãƒ‡ãƒ¼ã‚¿
        { name: "æ°´æ˜Ÿ", color: "#a9a9a9", baseRadius: 3, baseDist: 60, baseSpeed: 0.0060 },
        { name: "é‡‘æ˜Ÿ", color: "#e0c16c", baseRadius: 4, baseDist: 100, baseSpeed: 0.0045 },
        { name: "åœ°çƒ", color: "#4fc3f7", baseRadius: 4.5, baseDist: 150, baseSpeed: 0.0035, moons: 1 },
        { name: "ç«æ˜Ÿ", color: "#ff7043", baseRadius: 3.5, baseDist: 210, baseSpeed: 0.0028 },
        { name: "æœ¨æ˜Ÿ", color: "#fbc02d", baseRadius: 8, baseDist: 350, baseSpeed: 0.0015, moons: 4 },
        { name: "åœŸæ˜Ÿ", color: "#d1c4e9", baseRadius: 7, baseDist: 480, baseSpeed: 0.0010, moons: 3, ring: true },
        { name: "å¤©ç‹æ˜Ÿ", color: "#80cbc4", baseRadius: 6, baseDist: 600, baseSpeed: 0.0007 },
        { name: "æµ·ç‹æ˜Ÿ", color: "#bcaaa4", baseRadius: 5.8, baseDist: 720, baseSpeed: 0.0005 },
        //{ name: "å†¥ç‹æ˜Ÿ", color: "#a5d6a7", baseRadius: 2, baseDist: 850, baseSpeed: 0.0004 } // å†¥ç‹æ˜Ÿã¯ä»»æ„
    ];

    // --- åˆæœŸåŒ–é–¢æ•° ---
    function initSimulation() {
        generateStars();
        generatePlanets();
        generateAsteroids();
        spawnBlackHole(); // æœ€åˆã«å¿…ãšç”Ÿæˆ
        resetMeteor();
        animate(); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
    }

    // --- ç”Ÿæˆç³»é–¢æ•° ---
    function generateStars() {
        stars = [];
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: Math.random() * canvasWidth,
                y: Math.random() * canvasHeight,
                radius: Math.random() * 1.2,
                alpha: 0.3 + Math.random() * 0.5
            });
        }
    }

    function generatePlanets() {
        planets = [];
        planetBaseData.forEach((base, i) => {
            const angle = Math.random() * Math.PI * 2;
            const distance = base.baseDist + (Math.random() - 0.5) * 10; // å°‘ã—ã°ã‚‰ã¤ã
            const speed = base.baseSpeed * (0.9 + Math.random() * 0.2); // å°‘ã—ã°ã‚‰ã¤ã
            const radius = base.baseRadius * (0.9 + Math.random() * 0.2); // å°‘ã—ã°ã‚‰ã¤ã
            const planetData = {
                name: base.name, angle, distance, speed, radius, color: base.color,
                moons: [], originalDistance: distance, originalSpeed: speed
            };
            // æœˆ
            if (base.moons) {
                for (let m = 0; m < base.moons; m++) {
                    planetData.moons.push({
                        name: `è¡›æ˜Ÿ${m + 1}`,
                        distance: radius + 8 + m * 4 + Math.random() * 3,
                        angle: Math.random() * Math.PI * 2,
                        speed: 0.02 + Math.random() * 0.05,
                        radius: 0.8 + Math.random() * 0.8,
                        color: "#cccccc"
                    });
                }
            }
            // è¼ª
            if (base.ring) {
                planetData.ring = { color: "rgba(210, 190, 170, 0.5)", radius: radius + 8 + Math.random() * 4 };
            }
            planets.push(planetData);
        });
        logEvent("ğŸª æƒ‘æ˜Ÿç³»ç”Ÿæˆå®Œäº†");
    }

    function generateAsteroids() {
        asteroids = [];
        const mars = planets[3]; // ç«æ˜Ÿ
        const jupiter = planets[4]; // æœ¨æ˜Ÿ
        const beltStart = mars.originalDistance + mars.radius + 30;
        const beltEnd = jupiter.originalDistance - jupiter.radius - 30;

        for (let i = 0; i < ASTEROID_COUNT; i++) {
            const distance = beltStart + Math.random() * (beltEnd - beltStart);
            const angle = Math.random() * Math.PI * 2;
            // ã‚±ãƒ—ãƒ©ãƒ¼ã®æ³•å‰‡ã«å¾“ã„ã€å¤–å´ã»ã©é…ã (ç°¡æ˜“è¨ˆç®—)
            const speed = planets[3].originalSpeed * (mars.originalDistance / distance) * (0.8 + Math.random() * 0.4);
            const radius = 0.5 + Math.random() * 1.5; // å°ã•ãªã‚µã‚¤ã‚º
            asteroids.push({
                angle, distance, speed, radius,
                originalDistance: distance, originalSpeed: speed,
                // å²©ã‚‰ã—ã„å½¢ã®ãŸã‚ã®é ‚ç‚¹ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆç°¡æ˜“ï¼‰
                shapeOffsets: Array.from({length: 5}, () => ({
                    angle: Math.random() * Math.PI * 2,
                    dist: 0.7 + Math.random() * 0.6 // åŠå¾„ã«å¯¾ã™ã‚‹å€ç‡
                })).sort((a, b) => a.angle - b.angle), // è§’åº¦ã§ã‚½ãƒ¼ãƒˆ
                color: `rgb(${100 + Math.floor(Math.random()*50)}, ${100 + Math.floor(Math.random()*50)}, ${100 + Math.floor(Math.random()*50)})` // èŒ¶è‰²ã£ã½ã„è‰²
            });
        }
         logEvent("â˜„ï¸ å°æƒ‘æ˜Ÿå¸¯ç”Ÿæˆå®Œäº†");
    }

     function createExplosion(x, y, color = 'white', count = PARTICLE_COUNT) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 4; // çˆ†ç™ºé€Ÿåº¦
            const radius = 0.5 + Math.random() * 1.5;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius,
                color,
                life: PARTICLE_LIFESPAN, // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
                alpha: 0.8 + Math.random() * 0.2
            });
        }
    }

    function createClickEffect(x, y) {
        const duration = 30; // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
        clickEffects.push({
            x, y,
            life: duration,
            maxLife: duration,
            radius: 5,
            maxRadius: 20,
            alpha: 0.8
        });
    }

    function spawnBlackHole() { /* ... (å‰å›åŒæ§˜) ... */
        if (blackHole.timeoutId) clearTimeout(blackHole.timeoutId);
        blackHole.x = Math.random() * canvasWidth * 0.8 + canvasWidth * 0.1;
        blackHole.y = Math.random() * canvasHeight * 0.8 + canvasHeight * 0.1;
        blackHole.radius = 40 + Math.random() * 20;
        blackHole.active = true; blackHole.opacity = 0; blackHole.fadingOut = false; blackHole.angle = 0;
        blackHole.attractionRadius = 200 + Math.random() * 100;
        blackHole.pullStrength = 0.0006 + Math.random() * 0.0004;
        logEvent(`ğŸ•³ï¸ ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å‡ºç¾ (${Math.round(blackHole.x)}, ${Math.round(blackHole.y)})`);
        const duration = 15000 + Math.random() * 10000;
        blackHole.timeoutId = setTimeout(() => { blackHole.fadingOut = true; logEvent(`â³ ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«æ¶ˆæ»…é–‹å§‹`); }, duration - 3000);
        // å®‡å®™èˆ¹è„±å‡º
        spaceship.x = centerX; spaceship.y = centerY;
        const escapeAngle = Math.atan2(centerY - blackHole.y, centerX - blackHole.x);
        const escapeSpeed = 3 + Math.random() * 2;
        spaceship.vx = Math.cos(escapeAngle) * escapeSpeed; spaceship.vy = Math.sin(escapeAngle) * escapeSpeed;
        spaceship.active = true;
        logEvent(`ğŸš€ å®‡å®™èˆ¹ç·Šæ€¥è„±å‡ºé–‹å§‹`);
    }
    setInterval(spawnBlackHole, 20000 + Math.random() * 10000);

    function resetMeteor() { /* ... (å‰å›åŒæ§˜) ... */
        meteor.x = -meteor.radius; meteor.y = Math.random() * canvasHeight;
        meteor.speed = 5 + Math.random() * 5; meteor.radius = 5 + Math.random() * 10;
        meteor.angle = Math.atan2(Math.random() * canvasHeight - meteor.y, canvasWidth - meteor.x);
        meteor.active = true; meteor.tail = [];
    }
    setInterval(resetMeteor, 8000 + Math.random() * 5000);

    // --- æ›´æ–°é–¢æ•° ---
    function updateTime() {
        elapsedDays += TIME_SCALE;
        const newDate = new Date(startDate.getTime() + elapsedDays * 86400000);
        timestampEl.textContent = `æ—¥ä»˜: ${newDate.toLocaleDateString()} ${newDate.toLocaleTimeString()}`;
    }

    function logEvent(message) {
        const now = new Date(startDate.getTime() + elapsedDays * 86400000);
        const dateStr = now.toLocaleString();
        history.unshift(`[${dateStr}] ${message}`);
        if (history.length > MAX_HISTORY) history.pop();
        historyEl.textContent = history.join('\n');
        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ä¸€ç•ªä¸Šã«
        historyEl.scrollTop = 0;
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            p.alpha = (p.life / PARTICLE_LIFESPAN) * 0.9; // å¾ã€…ã«æ¶ˆãˆã‚‹

            // ç°¡å˜ãªæ¸›é€Ÿ
            p.vx *= 0.98;
            p.vy *= 0.98;

            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

     function updateClickEffects() {
        for (let i = clickEffects.length - 1; i >= 0; i--) {
            const effect = clickEffects[i];
            effect.life--;
            if (effect.life <= 0) {
                clickEffects.splice(i, 1);
            }
        }
    }

    // --- æç”»é–¢æ•° ---
    function drawNebula() {
        // èƒŒæ™¯ã«è¤‡æ•°ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é‡ã­ã¦æ˜Ÿé›²ã‚’æç”»
        ctx.save();
        ctx.globalCompositeOperation = 'lighter'; // è‰²ã‚’æ··ãœåˆã‚ã›ã‚‹

        // ä¾‹: ç´«ç³»ã®æ˜Ÿé›²
        let grad1 = ctx.createRadialGradient(canvasWidth * 0.2, canvasHeight * 0.3, 0, canvasWidth * 0.2, canvasHeight * 0.3, canvasWidth * 0.5);
        grad1.addColorStop(0, 'rgba(100, 0, 150, 0.05)');
        grad1.addColorStop(0.5, 'rgba(50, 0, 80, 0.02)');
        grad1.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad1;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // ä¾‹: é’ç·‘ç³»ã®æ˜Ÿé›²
        let grad2 = ctx.createRadialGradient(canvasWidth * 0.8, canvasHeight * 0.7, 0, canvasWidth * 0.8, canvasHeight * 0.7, canvasWidth * 0.4);
        grad2.addColorStop(0, 'rgba(0, 150, 180, 0.06)');
        grad2.addColorStop(0.6, 'rgba(0, 80, 100, 0.03)');
        grad2.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad2;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

         // ä¾‹: ãƒ”ãƒ³ã‚¯ç³»ã®æ˜Ÿé›²
        let grad3 = ctx.createRadialGradient(canvasWidth * 0.5, canvasHeight * 0.5, 0, canvasWidth * 0.5, canvasHeight * 0.5, canvasWidth * 0.6);
        grad3.addColorStop(0, 'rgba(200, 50, 100, 0.04)');
        grad3.addColorStop(0.7, 'rgba(100, 20, 50, 0.01)');
        grad3.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad3;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        ctx.restore(); // globalCompositeOperation ã‚’å…ƒã«æˆ»ã™
    }

    function drawStars() { /* ... (å‰å›åŒæ§˜) ... */
        stars.forEach(star => {
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
            ctx.fill();
        });
    }

    function drawSun(currentCenterX, currentCenterY, currentSunRadius) {
         // å¤ªé™½ã‚³ãƒ­ãƒŠ (å¤–å´ã®å…‰è¼ª)
        const coronaRadius = currentSunRadius * 2.5;
        const coronaGradient = ctx.createRadialGradient(currentCenterX, currentCenterY, currentSunRadius * 0.8, currentCenterX, currentCenterY, coronaRadius);
        coronaGradient.addColorStop(0, `rgba(255, 255, 200, 0.3)`);
        coronaGradient.addColorStop(0.5, `rgba(255, 200, 150, 0.1)`);
        coronaGradient.addColorStop(1, `rgba(255, 150, 0, 0)`);
        ctx.fillStyle = coronaGradient;
        ctx.beginPath();
        ctx.arc(currentCenterX, currentCenterY, coronaRadius, 0, Math.PI * 2);
        ctx.fill();

        // å¤ªé™½æœ¬ä½“
        const sunGradient = ctx.createRadialGradient(currentCenterX, currentCenterY, 0, currentCenterX, currentCenterY, currentSunRadius);
        sunGradient.addColorStop(0, "#ffffff");
        sunGradient.addColorStop(0.4, "#fff0a0");
        sunGradient.addColorStop(0.8, "#ffcc00");
        sunGradient.addColorStop(1, "#ff9900");
        ctx.fillStyle = sunGradient;
        ctx.shadowColor = "yellow";
        ctx.shadowBlur = 30 * pulse * scale; // ã‚ºãƒ¼ãƒ ã«åˆã‚ã›ã¦èª¿æ•´
        ctx.beginPath();
        ctx.arc(currentCenterX, currentCenterY, currentSunRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowColor = "transparent";

        // å¤ªé™½ãƒ©ãƒ™ãƒ« (ã‚ºãƒ¼ãƒ ã«å¿œã˜ã¦è¡¨ç¤º/éè¡¨ç¤º)
        if (scale > 0.5) {
            ctx.fillStyle = "#fff";
            ctx.font = `${Math.max(8, 14 * scale)}px sans-serif`; // ã‚µã‚¤ã‚ºã‚‚ã‚¹ã‚±ãƒ¼ãƒ«
            ctx.textAlign = "center";
            ctx.fillText("å¤ªé™½", currentCenterX, currentCenterY + currentSunRadius + 15 * scale);
            ctx.textAlign = "start";
        }
    }

    function drawPlanetsAndMoons(currentCenterX, currentCenterY) {
        for (let i = planets.length - 1; i >= 0; i--) {
            const p = planets[i];
            // åº§æ¨™è¨ˆç®— (ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨æ¸ˆã¿)
            let currentX = currentCenterX + Math.cos(p.angle) * p.distance;
            let currentY = currentCenterY + Math.sin(p.angle) * p.distance;
            let affectedByBlackHole = false;

            // --- ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å½±éŸ¿è¨ˆç®— (å‰å›åŒæ§˜) ---
             if (blackHole.active && blackHole.opacity > 0.1) {
                 const dx_p = blackHole.x - currentX;
                 const dy_p = blackHole.y - currentY;
                 const distSq_p = dx_p * dx_p + dy_p * dy_p;
                 const pullRadius = blackHole.attractionRadius; // ã‚ºãƒ¼ãƒ å½±éŸ¿ãªã—
                 const pullRadiusSq = pullRadius * pullRadius;

                 if (distSq_p < pullRadiusSq) {
                     affectedByBlackHole = true;
                     const dist_p = Math.sqrt(distSq_p);
                     const forceFactor = (pullRadiusSq - distSq_p) / pullRadiusSq;
                     const force_p = forceFactor * blackHole.pullStrength * blackHole.opacity;
                     currentX += dx_p * force_p;
                     currentY += dy_p * force_p;
                     const dCenterX = currentX - currentCenterX;
                     const dCenterY = currentY - currentCenterY;
                     p.distance = Math.sqrt(dCenterX * dCenterX + dCenterY * dCenterY);
                     p.angle = Math.atan2(dCenterY, dCenterX);
                     p.speed = p.originalSpeed * (p.distance / p.originalDistance);

                     const bhRadiusScaled = blackHole.radius; // ã‚ºãƒ¼ãƒ å½±éŸ¿ãªã—
                     if (dist_p < bhRadiusScaled + p.radius) {
                         logEvent(`ğŸ’¥ ${p.name} ãŒãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã«é£²ã¿è¾¼ã¾ã‚ŒãŸï¼`);
                         createExplosion(currentX, currentY, p.color); // çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                         planets.splice(i, 1);
                         continue;
                     }
                 } else { p.speed = p.originalSpeed; }
             } else { p.speed = p.originalSpeed; }
            // --- å½±éŸ¿è¨ˆç®—ã“ã“ã¾ã§ ---


            // è»Œé“æç”» (ã‚ºãƒ¼ãƒ ã«å¿œã˜ã¦ç·šã®å¤ªã•èª¿æ•´)
            ctx.beginPath();
            ctx.ellipse(currentCenterX, currentCenterY, p.distance, p.distance, 0, 0, Math.PI * 2);
            ctx.strokeStyle = affectedByBlackHole ? `rgba(255, 100, 100, ${0.15 * blackHole.opacity})` : "rgba(255, 255, 255, 0.08)";
            ctx.lineWidth = (affectedByBlackHole ? 1.5 : 1) / scale; // ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆã§å¤ªããªã‚Šã™ããªã„ã‚ˆã†ã«
            ctx.stroke();

            // æƒ‘æ˜Ÿæœ¬ä½“æç”»
            ctx.beginPath();
            ctx.arc(currentX, currentY, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = p.radius * 1.5 * scale; // å½±ã‚‚ã‚¹ã‚±ãƒ¼ãƒ«
            ctx.fill();
            ctx.shadowColor = "transparent";

            // æƒ‘æ˜Ÿãƒ©ãƒ™ãƒ« (ã‚ºãƒ¼ãƒ ã«å¿œã˜ã¦è¡¨ç¤º/éè¡¨ç¤º)
            if (scale > 0.6) {
                ctx.fillStyle = "#ffffff";
                ctx.font = `${Math.max(6, 11 * scale)}px sans-serif`;
                ctx.fillText(p.name, currentX + p.radius + 5 * scale, currentY + 4 * scale);
            }

             // åœŸæ˜Ÿã®è¼ª
             if (p.ring) {
                 ctx.strokeStyle = p.ring.color;
                 ctx.lineWidth = Math.max(0.5, 2 / scale); // è¼ªã®å¤ªã•ã‚‚èª¿æ•´
                 ctx.beginPath();
                 ctx.save();
                 ctx.translate(currentX, currentY);
                 ctx.rotate(0.3);
                 ctx.scale(1, 0.4);
                 ctx.arc(0, 0, p.ring.radius, 0, Math.PI * 2);
                 ctx.stroke();
                 ctx.restore();
             }

            // æœˆã®æ›´æ–°ãƒ»æç”»
            if (p.moons) {
                for (let j = p.moons.length - 1; j >= 0; j--) {
                    const m = p.moons[j];
                    m.angle += m.speed;
                    let mx = currentX + Math.cos(m.angle) * m.distance;
                    let my = currentY + Math.sin(m.angle) * m.distance;

                     // --- æœˆã®ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å½±éŸ¿è¨ˆç®— ---
                     if (blackHole.active && blackHole.opacity > 0.1) {
                         const dx_m = blackHole.x - mx;
                         const dy_m = blackHole.y - my;
                         const distSq_m = dx_m * dx_m + dy_m * dy_m;
                         const pullRadius_m = blackHole.attractionRadius * 0.8; // å½±éŸ¿ç¯„å›²
                         const pullRadiusSq_m = pullRadius_m * pullRadius_m;

                         if (distSq_m < pullRadiusSq_m) {
                             const dist_m = Math.sqrt(distSq_m);
                             const forceFactor_m = (pullRadiusSq_m - distSq_m) / pullRadiusSq_m;
                             const force_m = forceFactor_m * blackHole.pullStrength * 1.5 * blackHole.opacity;
                             mx += dx_m * force_m; my += dy_m * force_m;
                             const dPlanetX = mx - currentX; const dPlanetY = my - currentY;
                             m.distance = Math.sqrt(dPlanetX * dPlanetX + dPlanetY * dPlanetY);
                             m.angle = Math.atan2(dPlanetY, dPlanetX);

                             const bhRadiusScaled = blackHole.radius; // ã‚ºãƒ¼ãƒ å½±éŸ¿ãªã—
                             if (dist_m < bhRadiusScaled + m.radius) {
                                 logEvent(`ğŸ’¥ ${p.name}ã®${m.name} ãŒãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã«é£²ã¿è¾¼ã¾ã‚ŒãŸï¼`);
                                 createExplosion(mx, my, m.color, PARTICLE_COUNT / 2); // æœˆã®çˆ†ç™ºã¯å°‘ã—å°ã•ã‚
                                 p.moons.splice(j, 1);
                                 continue;
                             }
                         }
                     }
                     // --- å½±éŸ¿è¨ˆç®—ã“ã“ã¾ã§ ---

                    // æœˆæç”»
                    ctx.beginPath();
                    ctx.arc(mx, my, m.radius, 0, Math.PI * 2);
                    ctx.fillStyle = m.color;
                    ctx.fill();
                }
            }
            // æƒ‘æ˜Ÿã”ã¨ã®æ›´æ–°å‡¦ç†
            p.angle += p.speed;
        }
    }

    function drawAsteroids(currentCenterX, currentCenterY) {
        ctx.fillStyle = 'gray'; // å°æƒ‘æ˜Ÿã®è‰²ã¯å€‹åˆ¥ã«è¨­å®šã™ã‚‹ãŒã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

         for (let i = asteroids.length - 1; i >= 0; i--) {
             const a = asteroids[i];
             // åº§æ¨™è¨ˆç®—
             let currentX = currentCenterX + Math.cos(a.angle) * a.distance;
             let currentY = currentCenterY + Math.sin(a.angle) * a.distance;
             let affectedByBlackHole = false;

             // --- ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å½±éŸ¿è¨ˆç®— (æƒ‘æ˜Ÿã¨åŒæ§˜) ---
             if (blackHole.active && blackHole.opacity > 0.1) {
                 const dx_a = blackHole.x - currentX;
                 const dy_a = blackHole.y - currentY;
                 const distSq_a = dx_a * dx_a + dy_a * dy_a;
                 const pullRadius = blackHole.attractionRadius * 1.2; // å°æƒ‘æ˜Ÿã¯å½±éŸ¿å—ã‘ã‚„ã™ã„ã‹ã‚‚
                 const pullRadiusSq = pullRadius * pullRadius;

                 if (distSq_a < pullRadiusSq) {
                     affectedByBlackHole = true; // æç”»ç”¨ã«ãƒ•ãƒ©ã‚°ã ã‘ç«‹ã¦ã‚‹
                     const dist_a = Math.sqrt(distSq_a);
                     const forceFactor = (pullRadiusSq - distSq_a) / pullRadiusSq;
                     const force_a = forceFactor * blackHole.pullStrength * blackHole.opacity;
                     currentX += dx_a * force_a;
                     currentY += dy_a * force_a;
                     const dCenterX = currentX - currentCenterX;
                     const dCenterY = currentY - currentCenterY;
                     a.distance = Math.sqrt(dCenterX * dCenterX + dCenterY * dCenterY);
                     a.angle = Math.atan2(dCenterY, dCenterX);
                     a.speed = a.originalSpeed * (a.distance / a.originalDistance);

                     const bhRadiusScaled = blackHole.radius;
                     if (dist_a < bhRadiusScaled + a.radius) {
                         // logEvent(`ğŸ’¥ å°æƒ‘æ˜ŸãŒãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã«é£²ã¿è¾¼ã¾ã‚ŒãŸï¼`); // ãƒ­ã‚°ãŒå¤šã™ãã‚‹ã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
                         createExplosion(currentX, currentY, a.color, PARTICLE_COUNT / 5); // å°æƒ‘æ˜Ÿã®çˆ†ç™ºã¯å°ã•ã„
                         asteroids.splice(i, 1);
                         continue;
                     }
                 } else { a.speed = a.originalSpeed; }
             } else { a.speed = a.originalSpeed; }
             // --- å½±éŸ¿è¨ˆç®—ã“ã“ã¾ã§ ---


             // å°æƒ‘æ˜Ÿæç”» (å²©ã‚‰ã—ã„å½¢)
             ctx.beginPath();
             ctx.fillStyle = a.color;
             const startX = currentX + Math.cos(a.shapeOffsets[0].angle) * a.radius * a.shapeOffsets[0].dist;
             const startY = currentY + Math.sin(a.shapeOffsets[0].angle) * a.radius * a.shapeOffsets[0].dist;
             ctx.moveTo(startX, startY);
             a.shapeOffsets.slice(1).forEach(offset => {
                 const px = currentX + Math.cos(offset.angle) * a.radius * offset.dist;
                 const py = currentY + Math.sin(offset.angle) * a.radius * offset.dist;
                 ctx.lineTo(px, py);
             });
             ctx.closePath();
             ctx.fill();

             // å°æƒ‘æ˜Ÿã®æ›´æ–°
             a.angle += a.speed;
         }
    }

    function drawBlackHole() { /* ... (å‰å›åŒæ§˜ã€ãŸã ã—åº§æ¨™ç³»ã¯ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨æ¸ˆã¿) ... */
        if (!blackHole.active || blackHole.opacity <= 0) return;
        ctx.save();
        // åº§æ¨™ã¯ã™ã§ã«ã‚¹ã‚±ãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€translateã ã‘
        ctx.translate(blackHole.x, blackHole.y);
        ctx.globalAlpha = blackHole.opacity; // ã‚¢ãƒ«ãƒ•ã‚¡ã¯ã“ã“ã§è¨­å®š

        const currentRadius = blackHole.radius; // ã‚ºãƒ¼ãƒ ã®å½±éŸ¿ãªã—
        const currentDiskRadius = currentRadius * 3;

        // é™ç€å††ç›¤
        const gradientDisk = ctx.createRadialGradient(0, 0, currentRadius * 0.8, 0, 0, currentDiskRadius);
        gradientDisk.addColorStop(0, `rgba(0, 0, 0, 0)`);
        gradientDisk.addColorStop(0.3, `rgba(255, 100, 0, ${0.4 * blackHole.opacity})`);
        gradientDisk.addColorStop(0.6, `rgba(150, 50, 255, ${0.3 * blackHole.opacity})`);
        gradientDisk.addColorStop(1, `rgba(0, 0, 0, 0)`);
        ctx.rotate(blackHole.angle * 0.5);
        ctx.fillStyle = gradientDisk;
        ctx.beginPath();
        ctx.arc(0, 0, currentDiskRadius, 0, Math.PI * 2);
        ctx.arc(0, 0, currentRadius * 0.7, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.rotate(-blackHole.angle * 0.5);

        // æœ¬ä½“
        ctx.rotate(blackHole.angle);
        ctx.fillStyle = "black";
        ctx.shadowColor = "magenta";
        ctx.shadowBlur = 20 * blackHole.opacity * scale; // å½±ã‚‚ã‚¹ã‚±ãƒ¼ãƒ«
        ctx.beginPath();
        ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowColor = "transparent";
        ctx.rotate(-blackHole.angle);

        // å¢ƒç•Œç·š
        const pulse = 0.8 + 0.2 * Math.sin(Date.now() * 0.008);
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 * pulse * blackHole.opacity})`;
        ctx.lineWidth = 1.5 / scale; // ç·šå¹…èª¿æ•´
        ctx.beginPath();
        ctx.arc(0, 0, currentRadius + 2, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore(); // translateã¨globalAlphaã‚’æˆ»ã™

        // ãƒ©ãƒ™ãƒ« (ã‚ºãƒ¼ãƒ ã«å¿œã˜ã¦è¡¨ç¤º/éè¡¨ç¤º)
         if (scale > 0.4) {
             ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * blackHole.opacity})`;
             ctx.font = `${Math.max(8, 14 * scale)}px sans-serif`;
             ctx.textAlign = "center";
             ctx.fillText("Black Hole", blackHole.x, blackHole.y - currentRadius - 20 * scale);
             ctx.textAlign = "start";
         }
         // çŠ¶æ…‹æ›´æ–°
         blackHole.angle += 0.02;
    }

    function drawSpaceship() { /* ... (å‰å›åŒæ§˜ã€ãŸã ã—åº§æ¨™ç³»ã¯ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨æ¸ˆã¿) ... */
        if (!spaceship.active) return;
        // ä½ç½®æ›´æ–°
        spaceship.x += spaceship.vx;
        spaceship.y += spaceship.vy;
        // ç”»é¢å¤–åˆ¤å®š (ã‚ºãƒ¼ãƒ ã‚’è€ƒæ…®ã—ãªã„å…ƒã®åº§æ¨™ç³»ã§åˆ¤å®š)
        const margin = 50;
        if (spaceship.x < -margin || spaceship.x > canvasWidth + margin || spaceship.y < -margin || spaceship.y > canvasHeight + margin) {
            spaceship.active = false;
            logEvent("ğŸš€ å®‡å®™èˆ¹ã¯éŠ€æ²³å¤–ã¸è„±å‡ºæˆåŠŸ");
            return;
        }

        // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å½±éŸ¿ (ã‚ºãƒ¼ãƒ ã‚’è€ƒæ…®ã—ãªã„å…ƒã®åº§æ¨™ç³»ã§è¨ˆç®—)
        if (blackHole.active && blackHole.opacity > 0.1) {
            const dx = blackHole.x - spaceship.x;
            const dy = blackHole.y - spaceship.y;
            const distSq = dx * dx + dy * dy;
            const pullRadius = blackHole.attractionRadius * 0.5; // å½±éŸ¿ç¯„å›²
            const pullRadiusSq = pullRadius * pullRadius;
            if (distSq < pullRadiusSq) {
                const dist = Math.sqrt(distSq);
                const force = (pullRadiusSq - distSq) / pullRadiusSq * blackHole.pullStrength * 100 * blackHole.opacity;
                spaceship.vx += (dx / dist) * force;
                spaceship.vy += (dy / dist) * force;
            }
            const bhRadius = blackHole.radius;
            if (distSq < (bhRadius * bhRadius)) {
                spaceship.active = false;
                logEvent("ğŸ’¥ å®‡å®™èˆ¹ãŒãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã«æ•ç²ã•ã‚ŒãŸï¼");
                createExplosion(spaceship.x, spaceship.y, 'cyan'); // å®‡å®™èˆ¹ã®çˆ†ç™º
                return;
            }
        }

        // æç”» (ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨æ¸ˆã¿åº§æ¨™)
        ctx.save();
        ctx.translate(spaceship.x, spaceship.y);
        ctx.rotate(Math.atan2(spaceship.vy, spaceship.vx) + Math.PI / 2);
        const shipSize = 10; // åŸºæœ¬ã‚µã‚¤ã‚º (ã‚¹ã‚±ãƒ¼ãƒ«æœªé©ç”¨)

        // èˆ¹ä½“
        ctx.fillStyle = "white";
        ctx.shadowColor = "cyan";
        ctx.shadowBlur = 10 * scale;
        ctx.beginPath();
        ctx.moveTo(0, -shipSize); // å…ˆç«¯
        ctx.lineTo(shipSize * 0.5, shipSize * 0.5);  // å³ç¿¼
        ctx.lineTo(0, shipSize * 0.2);  // å°¾éƒ¨ä¸­å¤®
        ctx.lineTo(-shipSize * 0.5, shipSize * 0.5); // å·¦ç¿¼
        ctx.closePath();
        ctx.fill();

        // ã‚¨ãƒ³ã‚¸ãƒ³å™´å°„
        ctx.fillStyle = `rgba(255, 150, 0, ${0.5 + Math.random() * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(0, shipSize * 0.3);
        ctx.lineTo(shipSize * 0.2, shipSize * 0.7 + Math.random() * shipSize * 0.3);
        ctx.lineTo(-shipSize * 0.2, shipSize * 0.7 + Math.random() * shipSize * 0.3);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    function drawMeteor() { /* ... (å‰å›åŒæ§˜ã€ãŸã ã—åº§æ¨™ç³»ã¯ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨æ¸ˆã¿) ... */
        if (!meteor.active) return;
        // ä½ç½®æ›´æ–°
        meteor.x += Math.cos(meteor.angle) * meteor.speed;
        meteor.y += Math.sin(meteor.angle) * meteor.speed;
        // è»Œè·¡è¿½åŠ 
        meteor.tail.push({ x: meteor.x, y: meteor.y, radius: meteor.radius });
        if (meteor.tail.length > 20) meteor.tail.shift();
        // ç”»é¢å¤–åˆ¤å®š
        const mRadius = meteor.radius;
        if (meteor.x > canvasWidth + mRadius * 2 || meteor.y < -mRadius * 2 || meteor.y > canvasHeight + mRadius * 2) {
            meteor.active = false;
        } else {
            // è»Œè·¡æç”»
             for (let i = 0; i < meteor.tail.length; i++) {
                 const point = meteor.tail[i];
                 const alpha = (i / meteor.tail.length) * 0.5;
                 const radius = point.radius * (i / meteor.tail.length);
                 ctx.beginPath();
                 ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                 const r = 255; const g = 165 + (255 - 165) * (i / meteor.tail.length); const b = 0;
                 ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                 ctx.fill();
             }
             // æœ¬ä½“æç”»
             ctx.beginPath();
             const meteorGradient = ctx.createRadialGradient(meteor.x, meteor.y, 0, meteor.x, meteor.y, mRadius);
             meteorGradient.addColorStop(0, "white");
             meteorGradient.addColorStop(0.4, "yellow");
             meteorGradient.addColorStop(1, "orange");
             ctx.fillStyle = meteorGradient;
             ctx.shadowColor = "red";
             ctx.shadowBlur = 15 * scale;
             ctx.arc(meteor.x, meteor.y, mRadius, 0, Math.PI * 2);
             ctx.fill();
             ctx.shadowColor = "transparent";
        }
    }

    function drawParticles() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter'; // åŠ ç®—åˆæˆã§å…‰ã‚‰ã›ã‚‹
        particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * (p.life / PARTICLE_LIFESPAN), 0, Math.PI * 2); // å¯¿å‘½ã§ç¸®å°
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
        });
        ctx.restore(); // globalCompositeOperation, globalAlpha ã‚’æˆ»ã™
    }

     function drawClickEffects() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        clickEffects.forEach(effect => {
            const progress = effect.life / effect.maxLife; // 1 -> 0
            const currentRadius = effect.maxRadius * (1 - Math.pow(progress, 2)); // ã‚†ã£ãã‚ŠåºƒãŒã‚‹
            const currentAlpha = effect.alpha * Math.sin(progress * Math.PI); // ç‚¹æ»…ã—ã¦æ¶ˆãˆã‚‹

            ctx.beginPath();
            ctx.arc(effect.x, effect.y, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${currentAlpha * 0.8})`;
            ctx.lineWidth = 2 / scale;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(effect.x, effect.y, currentRadius * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(200, 200, 255, ${currentAlpha * 0.5})`;
            ctx.fill();
        });
        ctx.restore();
    }

    // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
    let lastTime = 0;
    function animate(currentTime = 0) {
        const deltaTime = currentTime - lastTime; // ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®æ™‚é–“ (ms)
        lastTime = currentTime;

        // --- çŠ¶æ…‹æ›´æ–° ---
        updateTime();
        updateParticles();
        updateClickEffects();

        // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«çŠ¶æ…‹æ›´æ–°
        if (blackHole.active) {
            if (!blackHole.fadingOut && blackHole.opacity < 1) {
                blackHole.opacity = Math.min(1, blackHole.opacity + FADE_SPEED);
            } else if (blackHole.fadingOut) {
                blackHole.opacity = Math.max(0, blackHole.opacity - FADE_SPEED);
                if (blackHole.opacity <= 0) {
                    blackHole.active = false; blackHole.timeoutId = null;
                    logEvent("âš« ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å®Œå…¨ã«æ¶ˆæ»…");
                }
            }
        }

        // ã‚ºãƒ¼ãƒ æ›´æ–° (ã‚¹ãƒ ãƒ¼ã‚º)
        scale += (targetScale - scale) * 0.1;
        zoomIndicatorEl.textContent = `Zoom: ${scale.toFixed(1)}x`; // ã‚ºãƒ¼ãƒ è¡¨ç¤ºæ›´æ–°

        // --- æç”»å‡¦ç† ---
        // ç”»é¢ã‚¯ãƒªã‚¢
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // æ˜Ÿé›²æç”»
        drawNebula();

        // --- ã‚ºãƒ¼ãƒ é©ç”¨é–‹å§‹ ---
        ctx.save();
        // ç”»é¢ä¸­å¿ƒåŸºæº–ã§ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
        ctx.translate(centerX, centerY);
        ctx.scale(scale, scale);
        ctx.translate(-centerX, -centerY);
        // Todo: è¦–ç‚¹ç§»å‹•ã‚’è¿½åŠ ã™ã‚‹å ´åˆã¯ã“ã“ã§ ctx.translate(-viewOffsetX, -viewOffsetY);

        // å„è¦ç´ ã®æç”» (ã‚ºãƒ¼ãƒ é©ç”¨ä¸‹)
        drawStars(); // æ˜Ÿå±‘ã¯ã‚ºãƒ¼ãƒ ã®å½±éŸ¿ã‚’å—ã‘ãªã„æ–¹ãŒè‡ªç„¶ã‹ã‚‚ï¼Ÿ -> ã„ã‚„ã€å—ã‘ã‚‹æ–¹ãŒçµ±ä¸€æ„Ÿã‚ã‚‹

        const pulse = 1 + 0.05 * Math.sin(Date.now() * 0.002);
        const sunRadius = 20 * pulse; // ã‚ºãƒ¼ãƒ å‰ã®åŸºæœ¬ã‚µã‚¤ã‚º
        drawSun(centerX, centerY, sunRadius); // å¤ªé™½ (ä¸­å¿ƒå›ºå®š)

        drawPlanetsAndMoons(centerX, centerY); // æƒ‘æ˜Ÿã¨æœˆ
        drawAsteroids(centerX, centerY); // å°æƒ‘æ˜Ÿå¸¯
        drawBlackHole(); // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«
        drawMeteor(); // æµæ˜Ÿ
        drawSpaceship(); // å®‡å®™èˆ¹
        drawParticles(); // ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        drawClickEffects(); // ã‚¯ãƒªãƒƒã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ

        // --- ã‚ºãƒ¼ãƒ é©ç”¨çµ‚äº† ---
        ctx.restore();

        // --- çŠ¶æ…‹ç®¡ç† ---
        // éŠ€æ²³æ»…äº¡ãƒã‚§ãƒƒã‚¯
        if (planets.length === 0 && asteroids.length < ASTEROID_COUNT * 0.1 && blackHole.opacity < 0.3) {
            logEvent("â˜„ï¸ éŠ€æ²³æ»…äº¡...æ–°ãŸãªéŠ€æ²³ã‚’ç”Ÿæˆã—ã¾ã™ã€‚");
            // å°‘ã—é–“ã‚’ç½®ã„ã¦å†ç”Ÿæˆ
            setTimeout(() => {
                generatePlanets();
                generateAsteroids();
                resetMeteor();
                spaceship.active = false;
            }, 2000); // 2ç§’å¾Œ
        }

        requestAnimationFrame(animate);
    }

    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
    window.addEventListener('resize', () => {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        centerX = canvasWidth / 2;
        centerY = canvasHeight / 2;
        generateStars(); // æ˜Ÿã¯ãƒªã‚µã‚¤ã‚ºæ™‚ã«å†ç”Ÿæˆ
    });

    window.addEventListener('unload', () => {
        if (blackHole.timeoutId) clearTimeout(blackHole.timeoutId);
        // ä»–ã®ã‚¿ã‚¤ãƒãƒ¼ãŒã‚ã‚Œã°ã‚¯ãƒªã‚¢
    });

    // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault(); // ãƒšãƒ¼ã‚¸ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
        const delta = e.deltaY > 0 ? -1 : 1; // ãƒ›ã‚¤ãƒ¼ãƒ«æ–¹å‘ (ä¸Š:1, ä¸‹:-1)
        targetScale += delta * ZOOM_SPEED * targetScale; // ç¾åœ¨ã®ã‚¹ã‚±ãƒ¼ãƒ«ã«å¿œã˜ã¦é€Ÿåº¦å¤‰åŒ–
        targetScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetScale)); // ç¯„å›²åˆ¶é™
    });

     // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
     canvas.addEventListener('click', (e) => {
         // ã‚¯ãƒªãƒƒã‚¯åº§æ¨™ã‚’Canvasåº§æ¨™ç³»ã«å¤‰æ› (ã‚ºãƒ¼ãƒ ã‚‚è€ƒæ…®)
         const rect = canvas.getBoundingClientRect();
         const clickX = (e.clientX - rect.left - centerX) / scale + centerX;
         const clickY = (e.clientY - rect.top - centerY) / scale + centerY;
         createClickEffect(clickX, clickY);
     });

    // (å°†æ¥ç”¨: ãƒ‰ãƒ©ãƒƒã‚°ã«ã‚ˆã‚‹è¦–ç‚¹ç§»å‹•)
    // canvas.addEventListener('mousedown', (e) => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; canvas.style.cursor = 'grabbing'; });
    // canvas.addEventListener('mousemove', (e) => { if (!isDragging) return; const dx = e.clientX - lastMouseX; const dy = e.clientY - lastMouseY; viewOffsetX -= dx / scale; viewOffsetY -= dy / scale; lastMouseX = e.clientX; lastMouseY = e.clientY; });
    // canvas.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'crosshair'; });
    // canvas.addEventListener('mouseleave', () => { isDragging = false; canvas.style.cursor = 'crosshair'; });

    // --- ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ ---
    initSimulation();

  </script>
</body>
</html>
