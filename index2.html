<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>é«˜åº¦ãªéŠ€æ²³ç³»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ âœ¦ GPU / CPU åˆ‡æ›¿å¯¾å¿œ & Nâ€‘Body ç‰©ç†</title>
  <!--
    â—‡ æ¦‚è¦
      * å…ƒã® 2D éŠ€æ²³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€GPU.js ã‚’ç”¨ã„ãŸä¸¦åˆ—é‡åŠ›è¨ˆç®—ã‚’è¿½åŠ ã€‚
      * ãƒœã‚¿ãƒ³ã§ GPU â‡” CPU ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã€‚
      * ã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’æ•´å½¢ & ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ã—ã¦ã€èª­ã¿ã‚„ã™ã•å„ªå…ˆã®ãƒ•ãƒ«ç‰ˆã§ã™ã€‚
  -->
  <style>
    /* ===== ãƒ™ãƒ¼ã‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ & UI ===== */
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    #controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      display: flex;
      gap: 10px;
      background: rgba(20, 20, 30, 0.75);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(120, 140, 255, 0.35);
      box-shadow: 0 0 18px rgba(70, 130, 240, 0.35);
      pointer-events: all;
    }

    button {
      background: rgba(60, 80, 170, 0.85);
      color: #fff;
      border: none;
      padding: 8px 14px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    button:hover {
      background: rgba(80, 100, 220, 0.95);
      box-shadow: 0 0 10px rgba(120, 170, 255, 0.7);
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #cce;
    }

    input[type="range"] {
      accent-color: rgb(90, 130, 255);
    }

    #log, #stats {
      position: fixed;
      font: 12px/1.45 monospace;
      background: rgba(10, 10, 30, 0.75);
      color: #cce;
      border: 1px solid rgba(120, 140, 255, 0.35);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(70, 130, 240, 0.35);
    }

    #log {
      top: 10px;
      right: 10px;
      max-width: 360px;
      max-height: 88vh;
      overflow-y: auto;
      white-space: pre-line;
    }

    #stats {
      bottom: 10px;
      right: 10px;
      pointer-events: none;
    }

    #log::-webkit-scrollbar {
      width: 5px;
    }

    #log::-webkit-scrollbar-thumb {
      background: rgba(100, 150, 255, 0.45);
      border-radius: 5px;
    }

    .tooltip {
      position: absolute;
      background: rgba(20, 30, 60, 0.85);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      border: 1px solid rgba(100, 150, 255, 0.45);
      z-index: 100;
    }
  </style>
  <!-- GPU.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/gpu.js@2.16.0/dist/gpu.min.js"></script>
</head>
<body>
  <canvas id="sim"></canvas>

  <!-- ===== UI ãƒ‘ãƒãƒ« ===== -->
  <div id="ui">
    <div id="controls">
      <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
      <button id="addPlanetBtn">æƒ‘æ˜Ÿè¿½åŠ </button>
      <button id="addStarBtn">æ’æ˜Ÿè¿½åŠ </button>
      <button id="toggleTrailBtn">è»Œé“éè¡¨ç¤º</button>
      <button id="toggleGpuBtn">GPU: OFF</button>

      <!-- æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ« -->
      <div class="slider-container">
        <span>æ™‚é–“é€Ÿåº¦:</span>
        <input type="range" id="timeSpeed" min="0.1" max="3" step="0.1" value="1" />
        <span id="timeValue">1.0x</span>
      </div>
      <!-- ã‚ºãƒ¼ãƒ  -->
      <div class="slider-container">
        <span>ã‚ºãƒ¼ãƒ :</span>
        <input type="range" id="zoomLevel" min="0.2" max="3" step="0.1" value="1" />
        <span id="zoomValue">1.0x</span>
      </div>
    </div>
  </div>

  <div id="log"></div>
  <div id="stats"></div>
  <div class="tooltip" id="tooltip"></div>

  <script>
  /* =========================================================
    1.  ã‚­ãƒ£ãƒ³ãƒã‚¹ & åŸºæœ¬ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  ========================================================= */
  const cvs = document.getElementById("sim");
  const ctx  = cvs.getContext("2d");
  const DPR  = window.devicePixelRatio || 1;

  let W, H, CX, CY;
  const TAU  = Math.PI * 2;
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randInt = (a, b) => Math.floor(rand(a, b + 1));

  function resize() {
    W = innerWidth;
    H = innerHeight;
    CX = W / 2;
    CY = H / 2;

    cvs.width  = W * DPR;
    cvs.height = H * DPR;
    cvs.style.width  = W + "px";
    cvs.style.height = H + "px";

    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  resize();
  window.addEventListener("resize", resize);

  /* =========================================================
    2.   è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ & ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç”¨å¤‰æ•°
  ========================================================= */
  const CONFIG = {
    G: 2e-4,                 // é‡åŠ›å®šæ•° (èª¿æ•´ç”¨)
    timeScale: 1,            // ã‚·ãƒŸãƒ¥ã®é€Ÿåº¦å€ç‡
    zoom: 1,                 // ã‚ºãƒ¼ãƒ å€ç‡
    showTrails: true,
    useGPU: false,           // GPU è¨ˆç®—ãƒ¢ãƒ¼ãƒ‰

    maxBodies: 2048          // GPU ã‚«ãƒ¼ãƒãƒ«ã®å›ºå®šã‚µã‚¤ã‚º (è¦ 2^n ã§ãªãã¦ã‚‚å¯)
  };

  /* =========================================================
    3.  ãƒ­ã‚° & ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ«
  ========================================================= */
  const logEl = document.getElementById("log");
  const logs  = [];
  function addLog(msg) {
    const t = new Date().toLocaleTimeString("ja-JP", {hour12:false});
    logs.unshift(`[${t}] ${msg}`);
    if (logs.length > 100) logs.pop();
    logEl.textContent = logs.join("\n");
    logEl.scrollTop = 0;
  }

  /* =========================================================
    4.  å¤©ä½“ã‚¯ãƒ©ã‚¹
  ========================================================= */
  class Body {
    constructor({name, color, m, r, x, y, vx=0, vy=0, type="planet"}) {
      Object.assign(this, {name, color, m, r, x, y, vx, vy, type});
      this.ax = this.ay = 0;
      this.trail = [];
      this.trailMax = 120;
      this.alive = true;
    }
    update(dt) {
      // ç°¡æ˜“ãƒªãƒ¼ãƒ—ãƒ•ãƒ­ãƒƒã‚°
      this.vx += this.ax * dt * 0.5 * CONFIG.timeScale;
      this.vy += this.ay * dt * 0.5 * CONFIG.timeScale;
      this.x  += this.vx * dt * CONFIG.timeScale;
      this.y  += this.vy * dt * CONFIG.timeScale;
      this.ax = this.ay = 0; // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ãƒªã‚»ãƒƒãƒˆ

      if (CONFIG.showTrails) {
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > this.trailMax) this.trail.shift();
      }
    }
    draw() {
      // â—† è»Œé“
      if (CONFIG.showTrails && this.trail.length > 1) {
        ctx.strokeStyle = this.color + "55";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(this.trail[0].x, this.trail[0].y);
        this.trail.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
      }
      // â—† æœ¬ä½“
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, TAU);
      ctx.fill();
    }
  }

  /* =========================================================
    5.  ä¸­å¿ƒæ’æ˜Ÿ (æç”»ã®ã¿ â€“ è¨ˆç®—ã§ã¯è³ªé‡ã‚’ç›´æ¥ä½¿ç”¨)
  ========================================================= */
  const SUN = {
    x: () => CX,
    y: () => CY,
    m: 1e7,
    r: 35,
    draw() {
      const g = ctx.createRadialGradient(this.x(), this.y(), 0, this.x(), this.y(), this.r * 3);
      g.addColorStop(0, "#fff");
      g.addColorStop(0.4, "#fff6b5");
      g.addColorStop(0.8, "#ffca28");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(this.x(), this.y(), this.r * 3, 0, TAU);
      ctx.fill();

      ctx.fillStyle = "#ffca28";
      ctx.beginPath();
      ctx.arc(this.x(), this.y(), this.r, 0, TAU);
      ctx.fill();
    }
  };

  /* =========================================================
    6.  åˆæœŸæƒ‘æ˜Ÿã‚»ãƒƒãƒˆç”Ÿæˆ
  ========================================================= */
  function spawnInitialBodies() {
    const data = [
      {n: "æ°´æ˜Ÿ", c: "#a9a9a9", m: 3,  r: 3,   d: 70},
      {n: "é‡‘æ˜Ÿ", c: "#e0c16c", m: 5,  r: 4,   d: 110},
      {n: "åœ°çƒ", c: "#4fc3f7", m: 6,  r: 4.8, d: 160},
      {n: "ç«æ˜Ÿ", c: "#ff7043", m: 3,  r: 3.5, d: 220},
      {n: "æœ¨æ˜Ÿ", c: "#fbc02d", m: 200, r: 8, d: 330}
    ];

    return data.map(p => {
      const ang = rand(0, TAU);
      const x = CX + Math.cos(ang) * p.d;
      const y = CY + Math.sin(ang) * p.d;
      const v = Math.sqrt(CONFIG.G * SUN.m / p.d);
      const vx = -Math.sin(ang) * v;
      const vy =  Math.cos(ang) * v;
      return new Body({name: p.n, color: p.c, m: p.m, r: p.r, x, y, vx, vy});
    });
  }

  let bodies = spawnInitialBodies();

  /* =========================================================
    7.  GPU.js ã‚«ãƒ¼ãƒãƒ«å®šç¾© & ãƒãƒƒãƒ•ã‚¡
  ========================================================= */
  const gpu = new GPU();
  let kernel;

  // å‹•çš„ã«æœ€å¤§æ•°ã‚’ç¢ºä¿ã™ã‚‹ (ç©ºãã¯ã‚¼ãƒ­è³ªé‡ã§ç„¡è¦–)
  let px = new Float32Array(CONFIG.maxBodies);
  let py = new Float32Array(CONFIG.maxBodies);
  let pvx = new Float32Array(CONFIG.maxBodies);
  let pvy = new Float32Array(CONFIG.maxBodies);
  let pm = new Float32Array(CONFIG.maxBodies);

  function buildKernel() {
    kernel = gpu.createKernel(function(px, py, pvx, pvy, pm, n, G, dt) {
      const i = this.thread.x;
      if (i >= n) return;

      let ax = 0.0,
          ay = 0.0;
      const xi = px[i];
      const yi = py[i];

      // ä¸­å¿ƒæ’æ˜Ÿã¨ã®é‡åŠ›
      const dxSun = this.constants.CX - xi;
      const dySun = this.constants.CY - yi;
      const r2Sun = dxSun*dxSun + dySun*dySun + 1e-6;
      let f = G * this.constants.SUN_M / r2Sun;
      let invRSun = 1.0 / Math.sqrt(r2Sun);
      ax += f * dxSun * invRSun;
      ay += f * dySun * invRSun;

      // ç›¸äº’é‡åŠ›
      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        const dx = px[j] - xi;
        const dy = py[j] - yi;
        const r2 = dx*dx + dy*dy + 1e-6;
        const invR3 = 1.0 / Math.pow(r2, 1.5);
        f = G * pm[j] * invR3;
        ax += f * dx;
        ay += f * dy;
      }

      let vx = pvx[i] + ax * dt;
      let vy = pvy[i] + ay * dt;
      const nx = xi + vx * dt;
      const ny = yi + vy * dt;

      // RGBA float ãƒ†ã‚¯ã‚¹ãƒãƒ£ã« (x, y, vx, vy) ã‚’è©°ã‚ã¦è¿”å´
      this.color(nx, ny, vx, vy);
    }, {
      output: [CONFIG.maxBodies],
      pipeline: true,
      immutable: true,
      constants: {
        CX: () => CX,
        CY: () => CY,
        SUN_M: SUN.m
      }
    });
  }
  buildKernel();

  function syncToArrays() {
    bodies.forEach((b, i) => {
      px[i]  = b.x;
      py[i]  = b.y;
      pvx[i] = b.vx;
      pvy[i] = b.vy;
      pm[i]  = b.m;
    });
  }

  function syncFromTexture(tex) {
    const flat = new Float32Array(tex.buffer);
    bodies.forEach((b, i) => {
      b.x  = flat[i*4];
      b.y  = flat[i*4 + 1];
      b.vx = flat[i*4 + 2];
      b.vy = flat[i*4 + 3];
    });
  }

  /* =========================================================
    8.  CPU åŠ›è¨ˆç®— (ç°¡æ˜“)
  ========================================================= */
  function cpuForces(dt) {
    for (let i = 0; i < bodies.length; i++) {
      const bi = bodies[i];

      // æ’æ˜Ÿ â†’ æƒ‘æ˜Ÿ
      {
        const dx = SUN.x() - bi.x;
        const dy = SUN.y() - bi.y;
        const r2 = dx*dx + dy*dy + 1e-6;
        const invR3 = Math.pow(r2, -1.5);
        const f = CONFIG.G * SUN.m * invR3;
        bi.ax += f * dx;
        bi.ay += f * dy;
      }

      // æƒ‘æ˜Ÿé–“ç›¸äº’ä½œç”¨
      for (let j = i + 1; j < bodies.length; j++) {
        const bj = bodies[j];
        const dx = bj.x - bi.x;
        const dy = bj.y - bi.y;
        const r2 = dx*dx + dy*dy + 1e-6;
        const invR3 = Math.pow(r2, -1.5);
        const f = CONFIG.G * invR3;
        const fx = f * dx;
        const fy = f * dy;

        bi.ax += fx * bj.m;
        bi.ay += fy * bj.m;
        bj.ax -= fx * bi.m;
        bj.ay -= fy * bi.m;
      }
    }

    bodies.forEach(b => b.update(dt));
  }

  /* =========================================================
    9.  UI ã‚¤ãƒ™ãƒ³ãƒˆ
  ========================================================= */
  const resetBtn       = document.getElementById("resetBtn");
  const addPlanetBtn   = document.getElementById("addPlanetBtn");
  const addStarBtn     = document.getElementById("addStarBtn");
  const toggleTrailBtn = document.getElementById("toggleTrailBtn");
  const toggleGpuBtn   = document.getElementById("toggleGpuBtn");
  const timeSpeed      = document.getElementById("timeSpeed");
  const timeValue      = document.getElementById("timeValue");
  const zoomLevel      = document.getElementById("zoomLevel");
  const zoomValue      = document.getElementById("zoomValue");
  const statsEl        = document.getElementById("stats");

  resetBtn.onclick = () => {
    bodies = spawnInitialBodies();
    addLog("ğŸ”„ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ");
  };

  addPlanetBtn.onclick = () => {
    const d = rand(80, 700);
    const ang = rand(0, TAU);
    const x = CX + Math.cos(ang) * d;
    const y = CY + Math.sin(ang) * d;
    const v = Math.sqrt(CONFIG.G * SUN.m / d);

    bodies.push(new Body({
      name: `æƒ‘æ˜Ÿ-${bodies.length + 1}`,
      color: `hsl(${randInt(0, 360)}, 70%, 60%)`,
      m: rand(2, 25),
      r: rand(3, 6),
      x, y,
      vx: -Math.sin(ang) * v,
      vy:  Math.cos(ang) * v
    }));

    addLog("ğŸª æƒ‘æ˜Ÿã‚’è¿½åŠ ");
  };

  addStarBtn.onclick = () => {
    const d = rand(200, 900);
    const ang = rand(0, TAU);
    const x = CX + Math.cos(ang) * d;
    const y = CY + Math.sin(ang) * d;
    const v = Math.sqrt(CONFIG.G * SUN.m / d) * 0.7;

    bodies.push(new Body({
      name: `æ’æ˜Ÿ-${bodies.length + 1}`,
      color: "#ff9800",
      m: rand(500, 2000),
      r: rand(12, 24),
      x, y,
      vx: -Math.sin(ang) * v,
      vy:  Math.cos(ang) * v,
      type: "star"
    }));

    addLog("â­ æ–°ã—ã„æ’æ˜Ÿã‚’è¿½åŠ ");
  };

  toggleTrailBtn.onclick = () => {
    CONFIG.showTrails = !CONFIG.showTrails;
    toggleTrailBtn.textContent = CONFIG.showTrails ? "è»Œé“éè¡¨ç¤º" : "è»Œé“è¡¨ç¤º";
  };

  toggleGpuBtn.onclick = () => {
    CONFIG.useGPU = !CONFIG.useGPU;
    toggleGpuBtn.textContent = `GPU: ${CONFIG.useGPU ? "ON" : "OFF"}`;
    addLog(`GPU ãƒ¢ãƒ¼ãƒ‰ã‚’ ${CONFIG.useGPU ? "ON" : "OFF"} ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ`);
  };

  timeSpeed.oninput = () => {
    CONFIG.timeScale = parseFloat(timeSpeed.value);
    timeValue.textContent = CONFIG.timeScale.toFixed(1) + "x";
  };

  zoomLevel.oninput = () => {
    CONFIG.zoom = parseFloat(zoomLevel.value);
    zoomValue.textContent = CONFIG.zoom.toFixed(1) + "x";
  };

  /* =========================================================
    10.  ãƒ¡ã‚¤ãƒ³æç”»ãƒ«ãƒ¼ãƒ—
  ========================================================= */
  let last = performance.now();
  function loop(now) {
    const dt = Math.min((now - last) / 16, 3); // 16ms â‰ˆ 60FPS
    last = now;

    // â˜… èƒŒæ™¯å¡—ã‚Šã¤ã¶ã— (ã‚·ãƒ³ãƒ—ãƒ«é»’)
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    // ã‚«ãƒ¡ãƒ©å¤‰æ›
    ctx.translate(CX * (CONFIG.zoom - 1), CY * (CONFIG.zoom - 1));
    ctx.scale(CONFIG.zoom, CONFIG.zoom);

    /* ------------ ç‰©ç†è¨ˆç®— ------------- */
    if (CONFIG.useGPU) {
      syncToArrays();
      const tex = kernel(px, py, pvx, pvy, pm, bodies.length, CONFIG.G * CONFIG.timeScale, dt * CONFIG.timeScale);
      syncFromTexture(tex);
    } else {
      cpuForces(dt);
    }

    /* ------------ æç”» ------------- */
    SUN.draw();
    bodies.forEach(b => b.draw());

    /* ------------ çµ±è¨ˆ ------------- */
    statsEl.textContent = `å¤©ä½“æ•°: ${bodies.length} | GPU: ${CONFIG.useGPU ? "ON" : "OFF"}`;

    requestAnimationFrame(loop);
  }

  addLog("ğŸŒŒ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ â€“ GPU ãƒœã‚¿ãƒ³ã§é«˜é€ŸåŒ–ã‚’è©¦ã—ã¦ã¿ã¦ã­ï¼");
  requestAnimationFrame(loop);
  </script>
</body>
</html>

