<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>éŠ€æ²³ç³»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆæœˆãƒ»ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«[ç›®ç«‹ã¤ç‰ˆ]ã‚ã‚Šï¼‰</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: radial-gradient(circle at center, #000000 0%, #0a0a0a 80%, #111111 100%);
      /* image-rendering: pixelated; */ /* æ»‘ã‚‰ã‹ãªæç”»ã®ãŸã‚ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ */
    }
    #timestamp {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 12px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="timestamp">Loading...</div>
  <canvas id="sim"></canvas>

  <script>
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // ä¸­å¿ƒåº§æ¨™ (let ã§å®£è¨€)
    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;

    let planets = [];
    const colors = ["#a9a9a9", "#e0c16c", "#4fc3f7", "#ff7043", "#fbc02d", "#d1c4e9", "#80cbc4"];
    const names = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus"];

    function generatePlanets() {
      planets = [];
      for (let i = 0; i < 7; i++) {
        const distance = 70 + i * 50;
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.008 + (i * 0.0015);
        const planetData = {
          name: names[i],
          angle,
          distance,
          speed,
          radius: 4 + i * 1.5,
          color: colors[i % colors.length],
          rotation: 0,
          rotationSpeed: 0.05 + Math.random() * 0.1,
          moons: [] // è¡›æ˜Ÿã‚’æ ¼ç´ã™ã‚‹é…åˆ—
        };

        // ä¾‹: 3ç•ªç›®ã®æƒ‘æ˜Ÿ(Earth)ã«æœˆã‚’è¿½åŠ 
        if (i === 2) {
          planetData.moons.push({
            name: "Moon",
            distance: planetData.radius + 15,
            angle: Math.random() * Math.PI * 2,
            speed: 0.05,
            radius: 2,
            color: "#cccccc"
          });
        }
        planets.push(planetData);
      }
    }

    generatePlanets();

    // ä¿®æ­£æ¸ˆã¿ã® drawGlow é–¢æ•°
    function drawGlow(x, y, r, color) {
        const glowRadius = Math.max(r, 5);
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowRadius);
        gradient.addColorStop(0, color);
        let transparentColor = 'transparent';
        try {
             if (typeof color === 'string') {
                if (color.startsWith('rgba')) {
                    transparentColor = color.replace(/,[^,]+?\)$/, ', 0)');
                } else if (color.startsWith('rgb')) {
                    transparentColor = color.replace('rgb', 'rgba').replace(')', ', 0)');
                } else if (color.startsWith('#')) {
                    let r = 0, g = 0, b = 0;
                    if (color.length === 7) {
                        r = parseInt(color.substring(1, 3), 16);
                        g = parseInt(color.substring(3, 5), 16);
                        b = parseInt(color.substring(5, 7), 16);
                        transparentColor = `rgba(${r}, ${g}, ${b}, 0)`;
                    } else if (color.length === 4) {
                        r = parseInt(color.substring(1, 2) + color.substring(1, 2), 16);
                        g = parseInt(color.substring(2, 3) + color.substring(2, 3), 16);
                        b = parseInt(color.substring(3, 4) + color.substring(3, 4), 16);
                        transparentColor = `rgba(${r}, ${g}, ${b}, 0)`;
                    }
                }
            }
        } catch (e) {
             console.error("Failed to create transparent color for:", color, e);
             transparentColor = 'transparent';
        }
        gradient.addColorStop(1, transparentColor);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, glowRadius * 1.2, 0, Math.PI * 2);
        ctx.fill();
    }


    const startDate = new Date("2025-01-01T00:00:00");
    let elapsedDays = 0;
    const timestampEl = document.getElementById("timestamp");

    function updateTime() {
      elapsedDays += 0.05;
      const newDate = new Date(startDate.getTime() + elapsedDays * 86400000);
      if (timestampEl) {
        timestampEl.textContent = newDate.toDateString();
      }
    }

    function generateMeteorName() {
      const num = Math.floor(100 + Math.random() * 900);
      return "METEOR-" + num;
    }

    let meteor = {
      x: -100,
      y: Math.random() * canvas.height,
      speed: 6 + Math.random() * 4,
      radius: 8 + Math.random() * 8,
      active: true,
      name: generateMeteorName()
    };

    let resetMeteorTimeout;
    function resetMeteor() {
        if (resetMeteorTimeout) {
            clearTimeout(resetMeteorTimeout);
        }
        meteor.x = -100;
        meteor.y = Math.random() * canvas.height;
        meteor.speed = 6 + Math.random() * 4;
        meteor.radius = 8 + Math.random() * 8;
        meteor.active = true;
        meteor.name = generateMeteorName();
        const nextMeteorTime = 10000 + Math.random() * 10000;
        resetMeteorTimeout = setTimeout(resetMeteor, nextMeteorTime);
    }
    resetMeteorTimeout = setTimeout(resetMeteor, 5000);


    // ğŸŒŒ ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«
    let blackHole = {
      x: 0,
      y: 0,
      radius: 25, // åˆæœŸå€¤ (spawnBlackHoleã§è¨­å®š)
      active: false,
      angle: 0,
      attractionRadius: 200,
      timeoutId: null
    };

    let spawnBlackHoleInterval;

    // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«å‡ºç¾é–¢æ•° (ä¿®æ­£ç‰ˆ)
    function spawnBlackHole() {
      if (blackHole.timeoutId) {
          clearTimeout(blackHole.timeoutId);
      }

      blackHole.x = Math.random() * canvas.width;
      blackHole.y = Math.random() * canvas.height;
      // â†“â†“â†“ ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã‚’è¦‹ã‚„ã™ãã™ã‚‹ãŸã‚ã®å¤‰æ›´ç‚¹ â†“â†“â†“
      blackHole.radius = 40 + Math.random() * 15; // åŠå¾„ã‚’å¤§ãã (40-55)
      const duration = 15000 + Math.random() * 5000; // å­˜åœ¨æ™‚é–“ã‚’é•·ã (15-20ç§’)
      // â†‘â†‘â†‘ ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã‚’è¦‹ã‚„ã™ãã™ã‚‹ãŸã‚ã®å¤‰æ›´ç‚¹ â†‘â†‘â†‘

      blackHole.active = true;
      blackHole.angle = 0;

      // â˜…â˜…â˜… ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°è¿½åŠ  â˜…â˜…â˜…
      console.log(`â˜…â˜…â˜… Black Hole spawned at (${Math.round(blackHole.x)}, ${Math.round(blackHole.y)}) Radius: ${Math.round(blackHole.radius)} Duration: ${duration/1000}s`);

      blackHole.timeoutId = setTimeout(() => {
        blackHole.active = false;
        blackHole.timeoutId = null;
         // â˜…â˜…â˜… ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°è¿½åŠ  â˜…â˜…â˜…
        console.log("â˜…â˜…â˜… Black Hole deactivated");
      }, duration);
    }

    // æœ€åˆã«ä¸€åº¦å‘¼ã³å‡ºã—ã€ãã®å¾Œã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’è¨­å®š
    spawnBlackHole();
    // â†“â†“â†“ ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã‚’è¦‹ã‚„ã™ãã™ã‚‹ãŸã‚ã®å¤‰æ›´ç‚¹ (å‡ºç¾é–“éš”ã‚’çŸ­ç¸®) â†“â†“â†“
    spawnBlackHoleInterval = setInterval(spawnBlackHole, 10000 + Math.random() * 5000); // 10-15ç§’é–“éš”
    // â†‘â†‘â†‘ ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã‚’è¦‹ã‚„ã™ãã™ã‚‹ãŸã‚ã®å¤‰æ›´ç‚¹ â†‘â†‘â†‘


    function update() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // ä¸­å¿ƒæ˜Ÿ (Sun)
      drawGlow(centerX, centerY, 60, "rgba(255, 255, 150, 0.4)");
      ctx.beginPath();
      ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffaa";
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Sun", centerX, centerY + 30);
      ctx.textAlign = "start";


      // æƒ‘æ˜Ÿã¨æœˆã®æç”»ã¨æ›´æ–°
      for (let i = planets.length - 1; i >= 0; i--) {
        if (!planets[i]) continue;
        const planet = planets[i];
        let planetDestroyed = false;

        planet.angle += planet.speed;
        planet.rotation += planet.rotationSpeed;
        let planetX = centerX + Math.cos(planet.angle) * planet.distance;
        let planetY = centerY + Math.sin(planet.angle) * planet.distance;

        // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã«ã‚ˆã‚‹æƒ‘æ˜Ÿã¸ã®å½±éŸ¿
        if (blackHole.active) {
          const dx = blackHole.x - planetX;
          const dy = blackHole.y - planetY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < blackHole.attractionRadius) {
              const force = (blackHole.attractionRadius - dist) * 0.0005;
              planetX += dx * force;
              planetY += dy * force;
              const dCenterX = planetX - centerX;
              const dCenterY = planetY - centerY;
              planet.distance = Math.sqrt(dCenterX*dCenterX + dCenterY*dCenterY);
              planet.angle = Math.atan2(dCenterY, dCenterX);
          }
          if (dist < blackHole.radius + planet.radius) {
            planets.splice(i, 1);
            planetDestroyed = true;
            continue;
          }
        }

        // éš•çŸ³ã«ã‚ˆã‚‹æƒ‘æ˜Ÿã¸ã®å½±éŸ¿
        if (!planetDestroyed && meteor.active) {
          const dx = meteor.x - planetX;
          const dy = meteor.y - planetY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < planet.radius + meteor.radius) {
            planets.splice(i, 1);
            meteor.active = false;
            resetMeteor();
            planetDestroyed = true;
            continue;
          }
        }

        // æƒ‘æ˜Ÿã®æç”»
        if (!planetDestroyed) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, planet.distance, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
            ctx.stroke();
            drawGlow(planetX, planetY, planet.radius * 3.5, planet.color);
            ctx.beginPath();
            ctx.arc(planetX, planetY, planet.radius, 0, Math.PI * 2);
            ctx.fillStyle = planet.color;
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.font = "11px sans-serif";
            ctx.fillText(planet.name, planetX + planet.radius + 5, planetY + 4);

            // æœˆã®å‡¦ç†
            if (planet.moons && planet.moons.length > 0) {
                for (let j = planet.moons.length - 1; j >= 0; j--) {
                    if (!planet.moons[j]) continue;
                    const moon = planet.moons[j];
                    let moonDestroyed = false;
                    moon.angle += moon.speed;
                    let moonX = planetX + Math.cos(moon.angle) * moon.distance;
                    let moonY = planetY + Math.sin(moon.angle) * moon.distance;

                    // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã«ã‚ˆã‚‹æœˆã¸ã®å½±éŸ¿
                    if (blackHole.active) {
                        const dx_m = blackHole.x - moonX;
                        const dy_m = blackHole.y - moonY;
                        const dist_m = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
                        if (dist_m < blackHole.attractionRadius * 0.5) {
                            const force_m = (blackHole.attractionRadius * 0.5 - dist_m) * 0.001;
                            moonX += dx_m * force_m;
                            moonY += dy_m * force_m;
                            const dPlanetX = moonX - planetX;
                            const dPlanetY = moonY - planetY;
                            if (dPlanetX !== 0 || dPlanetY !== 0) {
                                moon.distance = Math.sqrt(dPlanetX*dPlanetX + dPlanetY*dPlanetY);
                                moon.angle = Math.atan2(dPlanetY, dPlanetX);
                            }
                        }
                        if (dist_m < blackHole.radius + moon.radius) {
                            planet.moons.splice(j, 1);
                            moonDestroyed = true;
                            continue;
                        }
                    }

                    // éš•çŸ³ã«ã‚ˆã‚‹æœˆã¸ã®å½±éŸ¿
                    if (!moonDestroyed && meteor.active) {
                        const dx_m = meteor.x - moonX;
                        const dy_m = meteor.y - moonY;
                        const dist_m = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
                        if (dist_m < moon.radius + meteor.radius) {
                            planet.moons.splice(j, 1);
                            meteor.active = false;
                            resetMeteor();
                            moonDestroyed = true;
                            continue;
                        }
                    }

                    // æœˆã®æç”»
                    if (!moonDestroyed) {
                        ctx.beginPath();
                        ctx.arc(planetX, planetY, moon.distance, 0, Math.PI * 2);
                        ctx.strokeStyle = "rgba(200, 200, 200, 0.1)";
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(moonX, moonY, moon.radius, 0, Math.PI * 2);
                        ctx.fillStyle = moon.color;
                        ctx.fill();
                    }
                }
            }
        }
      }


      // éš•çŸ³ã®æç”»ã¨æ›´æ–°
      if (meteor.active) {
        meteor.x += meteor.speed;
        if (meteor.x > canvas.width + meteor.radius * 2) {
            meteor.active = false;
        } else {
            drawGlow(meteor.x, meteor.y, meteor.radius * 3, "rgba(255, 165, 0, 0.6)");
            ctx.beginPath();
            ctx.arc(meteor.x, meteor.y, meteor.radius, 0, Math.PI * 2);
            const meteorGradient = ctx.createRadialGradient(meteor.x - meteor.radius/3, meteor.y - meteor.radius/3, 1, meteor.x, meteor.y, meteor.radius);
            meteorGradient.addColorStop(0, "#ffcc66");
            meteorGradient.addColorStop(0.7, "#ff9933");
            meteorGradient.addColorStop(1, "#cc6600");
            ctx.fillStyle = meteorGradient;
            ctx.fill();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = "white";
            ctx.font = "10px sans-serif";
            ctx.fillText(meteor.name, meteor.x + meteor.radius + 4, meteor.y - meteor.radius - 4);
        }
      }

      // --- ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ã®æç”» (ä¿®æ­£ç‰ˆ) ---
      if (blackHole.active) {
         // console.log("Drawing Black Hole"); // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼ˆå¿…è¦ãªã‚‰ã‚³ãƒ¡ãƒ³ãƒˆè§£é™¤ï¼‰

        // å…ƒã®è¤‡é›‘ãªæç”»ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
        /*
        blackHole.angle += 0.03;
        ctx.save();
        ctx.translate(blackHole.x, blackHole.y);
        ctx.rotate(blackHole.angle);
        const accretionDiscRadius = blackHole.radius * 2.5;
        const accretionGradient = ctx.createRadialGradient(0, 0, blackHole.radius * 0.8, 0, 0, accretionDiscRadius);
        accretionGradient.addColorStop(0, "rgba(150, 50, 255, 0.1)");
        accretionGradient.addColorStop(0.5, "rgba(255, 100, 50, 0.3)");
        accretionGradient.addColorStop(1, "rgba(50, 50, 150, 0)");
        ctx.fillStyle = accretionGradient;
        ctx.beginPath();
        ctx.arc(0, 0, accretionDiscRadius, 0, Math.PI * 2);
        ctx.fill();
        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, blackHole.radius);
        coreGradient.addColorStop(0, "black");
        coreGradient.addColorStop(0.8, "black");
        coreGradient.addColorStop(1, "rgba(0, 0, 0, 0.5)");
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, blackHole.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(100, 100, 200, 0.3)";
        ctx.lineWidth = 1;
        for(let k=0; k<5; k++) {
            ctx.beginPath();
            ctx.arc(0, 0, blackHole.radius * (1.1 + k*0.2) + Math.sin(blackHole.angle*3 + k) * 3 , 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.restore();
        */

        // â˜…â˜…â˜… ã‚‚ã£ã¨ç›®ç«‹ã¤ä¸€æ™‚çš„ãªæç”» â˜…â˜…â˜…
        ctx.fillStyle = "rgba(255, 0, 255, 0.8)"; // æ˜ã‚‹ã„ãƒã‚¼ãƒ³ã‚¿è‰²
        ctx.beginPath();
        ctx.arc(blackHole.x, blackHole.y, blackHole.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "white"; // ç™½ã„æ ç·š
        ctx.lineWidth = 2;
        ctx.stroke();
        // â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜…

        // ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«æƒ…å ±ãƒ†ã‚­ã‚¹ãƒˆ (ä¿®æ­£ç‰ˆ)
        ctx.fillStyle = "#fff"; // ç™½è‰²ã§è¦‹ã‚„ã™ã
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center"; // ä¸­å¤®æƒãˆ
        ctx.fillText("Black Hole", blackHole.x, blackHole.y - blackHole.radius - 10); // ä½ç½®èª¿æ•´
        ctx.textAlign = "start"; // å…ƒã«æˆ»ã™
      }

      updateTime();
    }

    let animationFrameId;
    function animate() {
      update();
      animationFrameId = requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
        if (!animationFrameId) { // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ­¢ã¾ã£ã¦ã„ãŸã‚‰å†é–‹
           // animate(); // ã™ãå†é–‹ã™ã‚‹ã¨æç”»ãŒä¹±ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã®ã§ update() ã®ã¿å‘¼ã¶æ–¹ãŒè‰¯ã„ã‹ã‚‚
           update(); // ãƒªã‚µã‚¤ã‚ºå¾Œã®é™æ­¢ç”»ã‚’æ›´æ–°
           animate(); // ãã®å¾Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†é–‹
        }
    });

    animate();

    window.addEventListener('unload', () => {
        if (resetMeteorTimeout) clearTimeout(resetMeteorTimeout);
        if (spawnBlackHoleInterval) clearInterval(spawnBlackHoleInterval);
        if (blackHole.timeoutId) clearTimeout(blackHole.timeoutId);
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
    });

  </script>
</body>
</html>
