<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>銀河系シミュレーター（月・ブラックホール[目立つ版]あり）</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: radial-gradient(circle at center, #000000 0%, #0a0a0a 80%, #111111 100%);
      /* image-rendering: pixelated; */ /* 滑らかな描画のためにコメントアウト */
    }
    #timestamp {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 12px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="timestamp">Loading...</div>
  <canvas id="sim"></canvas>

  <script>
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // 中心座標 (let で宣言)
    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;

    let planets = [];
    const colors = ["#a9a9a9", "#e0c16c", "#4fc3f7", "#ff7043", "#fbc02d", "#d1c4e9", "#80cbc4"];
    const names = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus"];

    function generatePlanets() {
      planets = [];
      for (let i = 0; i < 7; i++) {
        const distance = 70 + i * 50;
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.008 + (i * 0.0015);
        const planetData = {
          name: names[i],
          angle,
          distance,
          speed,
          radius: 4 + i * 1.5,
          color: colors[i % colors.length],
          rotation: 0,
          rotationSpeed: 0.05 + Math.random() * 0.1,
          moons: [] // 衛星を格納する配列
        };

        // 例: 3番目の惑星(Earth)に月を追加
        if (i === 2) {
          planetData.moons.push({
            name: "Moon",
            distance: planetData.radius + 15,
            angle: Math.random() * Math.PI * 2,
            speed: 0.05,
            radius: 2,
            color: "#cccccc"
          });
        }
        planets.push(planetData);
      }
    }

    generatePlanets();

    // 修正済みの drawGlow 関数
    function drawGlow(x, y, r, color) {
        const glowRadius = Math.max(r, 5);
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowRadius);
        gradient.addColorStop(0, color);
        let transparentColor = 'transparent';
        try {
             if (typeof color === 'string') {
                if (color.startsWith('rgba')) {
                    transparentColor = color.replace(/,[^,]+?\)$/, ', 0)');
                } else if (color.startsWith('rgb')) {
                    transparentColor = color.replace('rgb', 'rgba').replace(')', ', 0)');
                } else if (color.startsWith('#')) {
                    let r = 0, g = 0, b = 0;
                    if (color.length === 7) {
                        r = parseInt(color.substring(1, 3), 16);
                        g = parseInt(color.substring(3, 5), 16);
                        b = parseInt(color.substring(5, 7), 16);
                        transparentColor = `rgba(${r}, ${g}, ${b}, 0)`;
                    } else if (color.length === 4) {
                        r = parseInt(color.substring(1, 2) + color.substring(1, 2), 16);
                        g = parseInt(color.substring(2, 3) + color.substring(2, 3), 16);
                        b = parseInt(color.substring(3, 4) + color.substring(3, 4), 16);
                        transparentColor = `rgba(${r}, ${g}, ${b}, 0)`;
                    }
                }
            }
        } catch (e) {
             console.error("Failed to create transparent color for:", color, e);
             transparentColor = 'transparent';
        }
        gradient.addColorStop(1, transparentColor);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, glowRadius * 1.2, 0, Math.PI * 2);
        ctx.fill();
    }


    const startDate = new Date("2025-01-01T00:00:00");
    let elapsedDays = 0;
    const timestampEl = document.getElementById("timestamp");

    function updateTime() {
      elapsedDays += 0.05;
      const newDate = new Date(startDate.getTime() + elapsedDays * 86400000);
      if (timestampEl) {
        timestampEl.textContent = newDate.toDateString();
      }
    }

    function generateMeteorName() {
      const num = Math.floor(100 + Math.random() * 900);
      return "METEOR-" + num;
    }

    let meteor = {
      x: -100,
      y: Math.random() * canvas.height,
      speed: 6 + Math.random() * 4,
      radius: 8 + Math.random() * 8,
      active: true,
      name: generateMeteorName()
    };

    let resetMeteorTimeout;
    function resetMeteor() {
        if (resetMeteorTimeout) {
            clearTimeout(resetMeteorTimeout);
        }
        meteor.x = -100;
        meteor.y = Math.random() * canvas.height;
        meteor.speed = 6 + Math.random() * 4;
        meteor.radius = 8 + Math.random() * 8;
        meteor.active = true;
        meteor.name = generateMeteorName();
        const nextMeteorTime = 10000 + Math.random() * 10000;
        resetMeteorTimeout = setTimeout(resetMeteor, nextMeteorTime);
    }
    resetMeteorTimeout = setTimeout(resetMeteor, 5000);


    // 🌌 ブラックホール
    let blackHole = {
      x: 0,
      y: 0,
      radius: 25, // 初期値 (spawnBlackHoleで設定)
      active: false,
      angle: 0,
      attractionRadius: 200,
      timeoutId: null
    };

    let spawnBlackHoleInterval;

    // ブラックホール出現関数 (修正版)
    function spawnBlackHole() {
      if (blackHole.timeoutId) {
          clearTimeout(blackHole.timeoutId);
      }

      blackHole.x = Math.random() * canvas.width;
      blackHole.y = Math.random() * canvas.height;
      // ↓↓↓ ブラックホールを見やすくするための変更点 ↓↓↓
      blackHole.radius = 40 + Math.random() * 15; // 半径を大きく (40-55)
      const duration = 15000 + Math.random() * 5000; // 存在時間を長く (15-20秒)
      // ↑↑↑ ブラックホールを見やすくするための変更点 ↑↑↑

      blackHole.active = true;
      blackHole.angle = 0;

      // ★★★ コンソールログ追加 ★★★
      console.log(`★★★ Black Hole spawned at (${Math.round(blackHole.x)}, ${Math.round(blackHole.y)}) Radius: ${Math.round(blackHole.radius)} Duration: ${duration/1000}s`);

      blackHole.timeoutId = setTimeout(() => {
        blackHole.active = false;
        blackHole.timeoutId = null;
         // ★★★ コンソールログ追加 ★★★
        console.log("★★★ Black Hole deactivated");
      }, duration);
    }

    // 最初に一度呼び出し、その後インターバルを設定
    spawnBlackHole();
    // ↓↓↓ ブラックホールを見やすくするための変更点 (出現間隔を短縮) ↓↓↓
    spawnBlackHoleInterval = setInterval(spawnBlackHole, 10000 + Math.random() * 5000); // 10-15秒間隔
    // ↑↑↑ ブラックホールを見やすくするための変更点 ↑↑↑


    function update() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 中心星 (Sun)
      drawGlow(centerX, centerY, 60, "rgba(255, 255, 150, 0.4)");
      ctx.beginPath();
      ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffaa";
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Sun", centerX, centerY + 30);
      ctx.textAlign = "start";


      // 惑星と月の描画と更新
      for (let i = planets.length - 1; i >= 0; i--) {
        if (!planets[i]) continue;
        const planet = planets[i];
        let planetDestroyed = false;

        planet.angle += planet.speed;
        planet.rotation += planet.rotationSpeed;
        let planetX = centerX + Math.cos(planet.angle) * planet.distance;
        let planetY = centerY + Math.sin(planet.angle) * planet.distance;

        // ブラックホールによる惑星への影響
        if (blackHole.active) {
          const dx = blackHole.x - planetX;
          const dy = blackHole.y - planetY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < blackHole.attractionRadius) {
              const force = (blackHole.attractionRadius - dist) * 0.0005;
              planetX += dx * force;
              planetY += dy * force;
              const dCenterX = planetX - centerX;
              const dCenterY = planetY - centerY;
              planet.distance = Math.sqrt(dCenterX*dCenterX + dCenterY*dCenterY);
              planet.angle = Math.atan2(dCenterY, dCenterX);
          }
          if (dist < blackHole.radius + planet.radius) {
            planets.splice(i, 1);
            planetDestroyed = true;
            continue;
          }
        }

        // 隕石による惑星への影響
        if (!planetDestroyed && meteor.active) {
          const dx = meteor.x - planetX;
          const dy = meteor.y - planetY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < planet.radius + meteor.radius) {
            planets.splice(i, 1);
            meteor.active = false;
            resetMeteor();
            planetDestroyed = true;
            continue;
          }
        }

        // 惑星の描画
        if (!planetDestroyed) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, planet.distance, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
            ctx.stroke();
            drawGlow(planetX, planetY, planet.radius * 3.5, planet.color);
            ctx.beginPath();
            ctx.arc(planetX, planetY, planet.radius, 0, Math.PI * 2);
            ctx.fillStyle = planet.color;
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.font = "11px sans-serif";
            ctx.fillText(planet.name, planetX + planet.radius + 5, planetY + 4);

            // 月の処理
            if (planet.moons && planet.moons.length > 0) {
                for (let j = planet.moons.length - 1; j >= 0; j--) {
                    if (!planet.moons[j]) continue;
                    const moon = planet.moons[j];
                    let moonDestroyed = false;
                    moon.angle += moon.speed;
                    let moonX = planetX + Math.cos(moon.angle) * moon.distance;
                    let moonY = planetY + Math.sin(moon.angle) * moon.distance;

                    // ブラックホールによる月への影響
                    if (blackHole.active) {
                        const dx_m = blackHole.x - moonX;
                        const dy_m = blackHole.y - moonY;
                        const dist_m = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
                        if (dist_m < blackHole.attractionRadius * 0.5) {
                            const force_m = (blackHole.attractionRadius * 0.5 - dist_m) * 0.001;
                            moonX += dx_m * force_m;
                            moonY += dy_m * force_m;
                            const dPlanetX = moonX - planetX;
                            const dPlanetY = moonY - planetY;
                            if (dPlanetX !== 0 || dPlanetY !== 0) {
                                moon.distance = Math.sqrt(dPlanetX*dPlanetX + dPlanetY*dPlanetY);
                                moon.angle = Math.atan2(dPlanetY, dPlanetX);
                            }
                        }
                        if (dist_m < blackHole.radius + moon.radius) {
                            planet.moons.splice(j, 1);
                            moonDestroyed = true;
                            continue;
                        }
                    }

                    // 隕石による月への影響
                    if (!moonDestroyed && meteor.active) {
                        const dx_m = meteor.x - moonX;
                        const dy_m = meteor.y - moonY;
                        const dist_m = Math.sqrt(dx_m * dx_m + dy_m * dy_m);
                        if (dist_m < moon.radius + meteor.radius) {
                            planet.moons.splice(j, 1);
                            meteor.active = false;
                            resetMeteor();
                            moonDestroyed = true;
                            continue;
                        }
                    }

                    // 月の描画
                    if (!moonDestroyed) {
                        ctx.beginPath();
                        ctx.arc(planetX, planetY, moon.distance, 0, Math.PI * 2);
                        ctx.strokeStyle = "rgba(200, 200, 200, 0.1)";
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(moonX, moonY, moon.radius, 0, Math.PI * 2);
                        ctx.fillStyle = moon.color;
                        ctx.fill();
                    }
                }
            }
        }
      }


      // 隕石の描画と更新
      if (meteor.active) {
        meteor.x += meteor.speed;
        if (meteor.x > canvas.width + meteor.radius * 2) {
            meteor.active = false;
        } else {
            drawGlow(meteor.x, meteor.y, meteor.radius * 3, "rgba(255, 165, 0, 0.6)");
            ctx.beginPath();
            ctx.arc(meteor.x, meteor.y, meteor.radius, 0, Math.PI * 2);
            const meteorGradient = ctx.createRadialGradient(meteor.x - meteor.radius/3, meteor.y - meteor.radius/3, 1, meteor.x, meteor.y, meteor.radius);
            meteorGradient.addColorStop(0, "#ffcc66");
            meteorGradient.addColorStop(0.7, "#ff9933");
            meteorGradient.addColorStop(1, "#cc6600");
            ctx.fillStyle = meteorGradient;
            ctx.fill();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = "white";
            ctx.font = "10px sans-serif";
            ctx.fillText(meteor.name, meteor.x + meteor.radius + 4, meteor.y - meteor.radius - 4);
        }
      }

      // --- ブラックホールの描画 (修正版) ---
      if (blackHole.active) {
         // console.log("Drawing Black Hole"); // デバッグ用（必要ならコメント解除）

        // 元の複雑な描画をコメントアウト
        /*
        blackHole.angle += 0.03;
        ctx.save();
        ctx.translate(blackHole.x, blackHole.y);
        ctx.rotate(blackHole.angle);
        const accretionDiscRadius = blackHole.radius * 2.5;
        const accretionGradient = ctx.createRadialGradient(0, 0, blackHole.radius * 0.8, 0, 0, accretionDiscRadius);
        accretionGradient.addColorStop(0, "rgba(150, 50, 255, 0.1)");
        accretionGradient.addColorStop(0.5, "rgba(255, 100, 50, 0.3)");
        accretionGradient.addColorStop(1, "rgba(50, 50, 150, 0)");
        ctx.fillStyle = accretionGradient;
        ctx.beginPath();
        ctx.arc(0, 0, accretionDiscRadius, 0, Math.PI * 2);
        ctx.fill();
        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, blackHole.radius);
        coreGradient.addColorStop(0, "black");
        coreGradient.addColorStop(0.8, "black");
        coreGradient.addColorStop(1, "rgba(0, 0, 0, 0.5)");
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, blackHole.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(100, 100, 200, 0.3)";
        ctx.lineWidth = 1;
        for(let k=0; k<5; k++) {
            ctx.beginPath();
            ctx.arc(0, 0, blackHole.radius * (1.1 + k*0.2) + Math.sin(blackHole.angle*3 + k) * 3 , 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.restore();
        */

        // ★★★ もっと目立つ一時的な描画 ★★★
        ctx.fillStyle = "rgba(255, 0, 255, 0.8)"; // 明るいマゼンタ色
        ctx.beginPath();
        ctx.arc(blackHole.x, blackHole.y, blackHole.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "white"; // 白い枠線
        ctx.lineWidth = 2;
        ctx.stroke();
        // ★★★ ここまで ★★★

        // ブラックホール情報テキスト (修正版)
        ctx.fillStyle = "#fff"; // 白色で見やすく
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center"; // 中央揃え
        ctx.fillText("Black Hole", blackHole.x, blackHole.y - blackHole.radius - 10); // 位置調整
        ctx.textAlign = "start"; // 元に戻す
      }

      updateTime();
    }

    let animationFrameId;
    function animate() {
      update();
      animationFrameId = requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
        if (!animationFrameId) { // アニメーションが止まっていたら再開
           // animate(); // すぐ再開すると描画が乱れる場合があるので update() のみ呼ぶ方が良いかも
           update(); // リサイズ後の静止画を更新
           animate(); // その後アニメーション再開
        }
    });

    animate();

    window.addEventListener('unload', () => {
        if (resetMeteorTimeout) clearTimeout(resetMeteorTimeout);
        if (spawnBlackHoleInterval) clearInterval(spawnBlackHoleInterval);
        if (blackHole.timeoutId) clearTimeout(blackHole.timeoutId);
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
    });

  </script>
</body>
</html>
